import { useState, useRef, useEffect } from "react";
import * as THREE from 'three';
import { Canvas } from "@react-three/fiber";
import { OrbitControls, useGLTF } from "@react-three/drei";
import "./App.css";

const GLOBAL_PIECE_SCALE = {
  pawn: 0.013,
  knight: 0.013,
  bishop: 0.013,
  rook: 0.013,
  queen: 0.013,
  king: 0.013,
};
const GHOST_SCALE_FACTOR = 0.6;

function Square({ position, color }) {
  return (
    <mesh position={position}>
      <boxGeometry args={[1, 0.15, 1]} />
      <meshStandardMaterial color={color} />
    </mesh>
  );
}

function BoardLevel({ y, flip = false }) {
  const squares = [];
  for (let x = 0; x < 8; x++) {
    for (let row = 0; row < 4; row++) {
      // within-board rows use logical y; flip so logical y=0 maps to visual top within board
      const yIndex = 3 - row;
      const isWhite = ((x + yIndex + (flip ? 1 : 0)) % 2) !== 0;
      squares.push(
        <Square
          key={`${y}-${x}-${row}`}
          // world coordinates: X, world Y (level), world Z (in-board row)
          position={[x - 3.5, y, yIndex - 3.5]}
          color={isWhite ? "#f0d9b5" : "#b58863"}
        />
      );
    }
  }
  return <group>{squares}</group>;
}

function QuadLevelBoard() {
  return (
    <group>
      <BoardLevel y={0} flip={true} />
      <BoardLevel y={3.725} flip={false} />
      <BoardLevel y={6.6} flip={true} />
      <BoardLevel y={8.75} flip={false} />
    </group>
  );
}

function Pieces({ piecesState, setPiecesState, selectedPieceId, setSelectedPieceId, isDragging, dragPoint, setIsDragging, setDragPoint, dragPointWorld, setDragPointWorld, controlsRef, pointerDownRef, pointerStartRef, setDragHeight, sceneScale, setPointerActive }) {
  const levels = [0, 3.725, 6.6, 8.75];
  const pieces = [];

  // Load GLB models from public/models
  const kingGltf = useGLTF('/models/king2.glb');
  const pawnGltf = useGLTF('/models/pawn2.glb');
  const knightGltf = useGLTF('/models/knight_-_staunton_full_size_chess_set.glb');
  const bishopGltf = useGLTF('/models/bishop_-_staunton_full_size_chess_set.glb');
  const rookGltf = useGLTF('/models/rook_-_staunton_full_size_chess_set.glb');
  const queenGltf = useGLTF('/models/queen_-_staunton_full_size_chess_set.glb');

  // Per-piece scale constants (tweak these if models look too big/small)
  const scaleMap = GLOBAL_PIECE_SCALE;

  function cloneAndColor(gltf, color) {
    const obj = gltf.scene.clone(true);
    obj.traverse((n) => {
      if (n.isMesh) {
        if (n.material) {
          n.material = n.material.clone();
          try { n.material.color.set(color); } catch (e) {}
          n.castShadow = true;
          n.receiveShadow = true;
        }
      }
    });
    return obj;
  }

  // piecesState is an array of piece objects with {id,x,y,z,t,color}
  const allPieces = piecesState;

  // occupancy set keyed by logical coords
  const occupied = new Set(allPieces.map((p) => `${p.x},${p.y},${p.z}`));

  // helper to convert logical coords to world positions
  function worldPosFromLogical(lx, ly, lz) {
    const wx = lx - 3.5;
    const wy = levels[lz] + 0.11;
    const wz = (3 - ly) - 3.5;
    return [wx, wy, wz];
  }

  // compute legal moves for a selected white piece (pawns + knights)
  const occupiedMap = new Map(allPieces.map((p) => [`${p.x},${p.y},${p.z}`, p.color]));
  let legalMoves = [];
  if (selectedPieceId != null) {
    const sel = allPieces.find((pp) => pp.id === selectedPieceId);
    if (sel && sel.color === 'white') {
      const { x: sx, y: sy, z: sz, t: st } = sel;

      // Pawn moves (white moves toward decreasing x)
      if (st === 'p') {
        const oneX = sx - 1;
        const twoX = sx - 2;
        if (oneX >= 0 && !occupiedMap.has(`${oneX},${sy},${sz}`)) {
          legalMoves.push({ x: oneX, y: sy, z: sz });
          if (sx === 6 && twoX >= 0 && !occupiedMap.has(`${twoX},${sy},${sz}`)) {
            legalMoves.push({ x: twoX, y: sy, z: sz });
          }
        }
      }

      // Knight moves in 3D: all permutations of (2,1,0) across axes with sign combos
      if (st === 'N') {
        const perms = [
          [2, 1, 0], [2, 0, 1], [1, 2, 0], [1, 0, 2], [0, 2, 1], [0, 1, 2],
        ];
        const moveSet = new Set();
        perms.forEach(([ax, ay, az]) => {
          const xs = ax === 0 ? [0] : [-ax, ax];
          const ys = ay === 0 ? [0] : [-ay, ay];
          const zs = az === 0 ? [0] : [-az, az];
          xs.forEach((dx) => ys.forEach((dy) => zs.forEach((dz) => {
            const nx = sx + dx;
            const ny = sy + dy;
            const nz = sz + dz;
            // bounds: x in 0..7, y in 0..3, z in 0..3
            if (nx < 0 || nx > 7 || ny < 0 || ny > 3 || nz < 0 || nz > 3) return;
            const key = `${nx},${ny},${nz}`;
            // can't land on own piece
            if (occupiedMap.get(key) === 'white') return;
            moveSet.add(key);
          })));
        });
        moveSet.forEach((k) => {
          const [x, y, z] = k.split(',').map(Number);
          legalMoves.push({ x, y, z });
        });
      }
    }
  }

  // render all pieces
  allPieces.forEach((p, idx) => {
    const world = worldPosFromLogical(p.x, p.y, p.z);
    const modelMap = {
      R: rookGltf,
      N: knightGltf,
      B: bishopGltf,
      K: kingGltf,
      Q: queenGltf,
      p: pawnGltf,
    };
    const gltf = modelMap[p.t] || pawnGltf;
    const pieceNameMap = { N: 'knight', B: 'bishop', K: 'king', Q: 'queen' };
    const s = scaleMap[pieceNameMap[p.t] || 'pawn'];

    // clickable group for white pawns and knights
    const isWhite = p.color === 'white';
    const isSelected = selectedPieceId === p.id;
    // When selected and pointer-down/dragging, render the piece at the computed local `dragPoint`
    const pos = isSelected && (isDragging || (pointerDownRef && pointerDownRef.current)) ? dragPoint : world;
    const visible = !(isSelected && (isDragging || (pointerDownRef && pointerDownRef.current)));
    pieces.push(
      <group
        key={`${p.id}-${p.t}-${idx}`}
        position={pos}
        visible={visible}
            onPointerDown={(e) => {
          e.stopPropagation();
          // toggle selection when clicking same piece
          if ((p.t === 'p' || p.t === 'N') && isWhite) {
            if (selectedPieceId === p.id) {
              setSelectedPieceId(null);
              pointerDownRef.current = false;
              pointerStartRef.current = null;
                  try { if (controlsRef.current) controlsRef.current.enabled = true; } catch {}
                  try { if (setPointerActive) setPointerActive(false); } catch {}
              return;
            }
            setSelectedPieceId(p.id);
            // record pointer-down start and initial drag height; don't start dragging yet
            pointerDownRef.current = true;
            pointerStartRef.current = e.point || null;
            setDragPoint(world);
                setDragHeight(world[1]);
                try { if (setDragPointWorld) setDragPointWorld([e.point.x, e.point.y, e.point.z]); } catch {}
                try { if (setPointerActive) setPointerActive(true); } catch {}
            // immediately disable OrbitControls so the board doesn't move while attempting drag
            try { if (controlsRef.current) controlsRef.current.enabled = false; } catch {}
          } else {
            setSelectedPieceId(null);
          }
        }}
      >
        <primitive
          object={cloneAndColor(gltf, isWhite ? '#ffffff' : '#615c5c')}
          scale={s}
          rotation={isWhite ? [0, Math.PI, 0] : [0, 0, 0]}
        />
      </group>
    );
  });

  // render move indicators (red dots)
  function moveTo(target) {
    if (selectedPieceId == null) return;
    setPiecesState((prev) => {
      // remove any black piece at target (capture)
      const withoutCaptured = prev.filter(
        (pp) => !(pp.x === target.x && pp.y === target.y && pp.z === target.z && pp.color === 'black')
      );
      // move the selected piece
      return withoutCaptured.map((pp) =>
        pp.id === selectedPieceId ? { ...pp, x: target.x, y: target.y, z: target.z } : pp
      );
    });
    setSelectedPieceId(null);
  }

  const indicators = legalMoves.map((m, i) => {
    const wp = worldPosFromLogical(m.x, m.y, m.z);
    return (
      <mesh key={`move-ind-${i}`} position={wp} onPointerUp={(e) => { e.stopPropagation(); moveTo(m); try { if (controlsRef.current) controlsRef.current.enabled = true; } catch{} }}>
        <sphereGeometry args={[0.14, 16, 16]} />
        <meshStandardMaterial color="#ff0000" />
      </mesh>
    );
  });

  return <group>{pieces.concat(indicators)}</group>;
}

function Ghost({ dragPointWorld, selectedPieceId, piecesState, sceneScale }) {
  const kingGltf = useGLTF('/models/king2.glb');
  const pawnGltf = useGLTF('/models/pawn2.glb');
  const knightGltf = useGLTF('/models/knight_-_staunton_full_size_chess_set.glb');
  const bishopGltf = useGLTF('/models/bishop_-_staunton_full_size_chess_set.glb');
  const rookGltf = useGLTF('/models/rook_-_staunton_full_size_chess_set.glb');
  const queenGltf = useGLTF('/models/queen_-_staunton_full_size_chess_set.glb');
  if (!dragPointWorld || selectedPieceId == null) return null;

  function cloneAndColor(gltf, color) {
    const obj = gltf.scene.clone(true);
    obj.traverse((n) => {
      if (n.isMesh) {
        if (n.material) {
          n.material = n.material.clone();
          try { n.material.color.set(color); n.material.transparent = true; n.material.opacity = 0.85; } catch (e) {}
          n.castShadow = true;
          n.receiveShadow = true;
        }
      }
    });
    return obj;
  }

  const sel = piecesState.find((p) => p.id === selectedPieceId);
  if (!sel) return null;
  const modelMap = {
    R: rookGltf,
    N: knightGltf,
    B: bishopGltf,
    K: kingGltf,
    Q: queenGltf,
    p: pawnGltf,
  };
  const gltf = modelMap[sel.t] || pawnGltf;
  const pieceNameMap = { N: 'knight', B: 'bishop', K: 'king', Q: 'queen' };
  const s = GLOBAL_PIECE_SCALE[pieceNameMap[sel.t] || 'pawn'] * sceneScale * GHOST_SCALE_FACTOR;

  return (
    <group position={dragPointWorld} raycast={() => null}>
      <primitive object={cloneAndColor(gltf, sel.color === 'white' ? '#ffffff' : '#615c5c')} scale={s} />
    </group>
  );
}

export default function App() {
  const [aiSide, setAiSide] = useState(null);
  const [selectedPieceId, setSelectedPieceId] = useState(null);
  const [isDragging, setIsDragging] = useState(false);
  const [dragPoint, setDragPoint] = useState([0, 0, 0]);
  const [dragHeight, setDragHeight] = useState(0);
  const [dragPointWorld, setDragPointWorld] = useState(null);
  const [pointerActive, setPointerActive] = useState(false);
  const pointerDownRef = useRef(false);
  const pointerStartRef = useRef(null);
  const groupRef = useRef();
  const sceneScale = 0.470;

  // when pointerActive, listen to global pointermove to compute continuous world drag point
  useEffect(() => {
    if (!pointerActive) return;
    const onMove = (ev) => {
      try {
        const canvas = document.querySelector('canvas');
        if (!canvas) return;
        const rect = canvas.getBoundingClientRect();
        const x = ((ev.clientX - rect.left) / rect.width) * 2 - 1;
        const y = -((ev.clientY - rect.top) / rect.height) * 2 + 1;
        const cam = controlsRef.current && controlsRef.current.object;
        if (!cam) return;
        const ndc = new THREE.Vector2(x, y);
        const raycaster = new THREE.Raycaster();
        raycaster.setFromCamera(ndc, cam);
        const ro = raycaster.ray.origin;
        const rd = raycaster.ray.direction;
        // intersect with horizontal plane at world Y = dragHeight
        const planeY = dragHeight;
        if (Math.abs(rd.y) < 1e-6) return;
        const t = (planeY - ro.y) / rd.y;
        const hit = new THREE.Vector3().copy(rd).multiplyScalar(t).add(ro);
        setDragPointWorld([hit.x, hit.y, hit.z]);
        // also update local dragPoint
        if (groupRef.current) {
          const v = hit.clone();
          groupRef.current.worldToLocal(v);
          v.y = dragHeight;
          setDragPoint([v.x, v.y, v.z]);
        } else {
          setDragPoint([hit.x / sceneScale, dragHeight, hit.z / sceneScale]);
        }
      } catch (e) {}
    };
    window.addEventListener('pointermove', onMove);
    return () => window.removeEventListener('pointermove', onMove);
  }, [pointerActive, dragHeight, sceneScale]);

  // build initial pieces list (logical coords)
  function getInitialPieces() {
    const levels = [0, 1, 2, 3]; // logical levels
    const res = [];
    let id = 1;
    levels.forEach((lz) => {
      for (let row = 0; row < 4; row++) {
        res.push({ id: id++, x: 1, y: row, z: lz, t: 'p', color: 'black' });
        res.push({ id: id++, x: 6, y: row, z: lz, t: 'p', color: 'white' });
      }
    });

    const placements = [
      { x: 0, y: 0, z: 0, t: 'R' },
      { x: 0, y: 1, z: 0, t: 'N' },
      { x: 0, y: 2, z: 0, t: 'B' },
      { x: 0, y: 3, z: 0, t: 'R' },
      { x: 0, y: 0, z: 1, t: 'B' },
      { x: 0, y: 1, z: 1, t: 'K' },
      { x: 0, y: 2, z: 1, t: 'Q' },
      { x: 0, y: 3, z: 1, t: 'N' },
      { x: 0, y: 0, z: 2, t: 'N' },
      { x: 0, y: 1, z: 2, t: 'Q' },
      { x: 0, y: 2, z: 2, t: 'K' },
      { x: 0, y: 3, z: 2, t: 'B' },
      { x: 0, y: 0, z: 3, t: 'R' },
      { x: 0, y: 1, z: 3, t: 'B' },
      { x: 0, y: 2, z: 3, t: 'N' },
      { x: 0, y: 3, z: 3, t: 'R' },
    ];
    placements.forEach((p) => {
      res.push({ id: id++, x: p.x, y: p.y, z: p.z, t: p.t, color: 'black' });
      res.push({ id: id++, x: 7 - p.x, y: p.y, z: p.z, t: p.t, color: 'white' });
    });
    return res;
  }

  const [piecesState, setPiecesState] = useState(() => getInitialPieces());

  // camera / controls persistence
  const controlsRef = useRef();
  // prefer explicit saved defaults if present; otherwise fall back to last-used camPos
  const [camPos, setCamPos] = useState(() => {
    try {
      return JSON.parse(localStorage.getItem('camDefaultPos')) || JSON.parse(localStorage.getItem('camPos')) || [6, 5, -8];
    } catch { return [6,5,-8]; }
  });
  const [camTarget, setCamTarget] = useState(() => {
    try {
      return JSON.parse(localStorage.getItem('camDefaultTarget')) || JSON.parse(localStorage.getItem('camTarget')) || [0, 1.7, 0];
    } catch { return [0,1.7,0]; }
  });

  useEffect(() => {
    // apply saved target to controls when they mount
    if (controlsRef.current) {
      const c = controlsRef.current;
      if (c.target && Array.isArray(camTarget)) {
        c.target.set(camTarget[0], camTarget[1], camTarget[2]);
        c.update();
      }
      // ensure camera position if accessible
      if (c.object && Array.isArray(camPos)) {
        c.object.position.set(camPos[0], camPos[1], camPos[2]);
      }
    }
  }, [controlsRef, camPos, camTarget]);



  return (
    <div className="layout">
      <aside className="sidebar">
        <h2 className="title">Quadlevel 3D Chess</h2>
        <div className="menu">
          <button className="menu-button" onClick={() => setAiSide('white')}>
            Play AI White
          </button>
          <button className="menu-button" onClick={() => setAiSide('black')}>
            Play AI Black
          </button>
        </div>
        {aiSide && <div className="status">AI playing: {aiSide}</div>}
      </aside>
      <main className="main">
        <Canvas
          className="canvas"
          camera={{ position: camPos, fov: 32 }}
          onPointerMove={(e) => {
            if (!e.point) return;
            // if pointer was pressed on a piece and user moved enough, start dragging
            if (pointerDownRef.current && !isDragging && selectedPieceId != null && pointerStartRef.current) {
              const dx = e.point.x - pointerStartRef.current.x;
              const dz = e.point.z - pointerStartRef.current.z;
              const dist = Math.hypot(dx, dz);
              // smaller threshold so drag starts reliably
              if (dist > 0.03) {
                setIsDragging(true);
                try { if (controlsRef.current) controlsRef.current.enabled = false; } catch {}
              }
            }
            // update drag point while pointer is down (so piece follows cursor immediately) or when dragging
            if (pointerDownRef.current || isDragging) {
              // store world-point for optional ghost rendering
              setDragPointWorld([e.point.x, e.point.y, e.point.z]);
              // convert world pointer to the group's local coordinates for accurate placement
              if (groupRef.current) {
                const v = new THREE.Vector3(e.point.x, e.point.y, e.point.z);
                groupRef.current.worldToLocal(v);
                // keep the desired local drag height so piece doesn't sink
                v.y = dragHeight;
                setDragPoint([v.x, v.y, v.z]);
              } else {
                // fallback to scaled coords
                setDragPoint([e.point.x / sceneScale, dragHeight, e.point.z / sceneScale]);
              }
            }
          }}
          onPointerUp={(e) => {
            // release drag anywhere (if not dropped on indicator)
            pointerDownRef.current = false;
            pointerStartRef.current = null;
            setIsDragging(false);
            setDragPointWorld(null);
            // always re-enable controls on pointer up
            try { if (controlsRef.current) controlsRef.current.enabled = true; } catch {}
          }}
        >
          <ambientLight intensity={0.6} />
          <directionalLight position={[5, 12, 5]} intensity={0.9} />
          <group ref={groupRef} scale={sceneScale}>
            <QuadLevelBoard />
            <Pieces
              piecesState={piecesState}
              setPiecesState={setPiecesState}
              selectedPieceId={selectedPieceId}
              setSelectedPieceId={setSelectedPieceId}
              isDragging={isDragging}
              dragPoint={dragPoint}
              setIsDragging={setIsDragging}
              setDragPoint={setDragPoint}
              dragPointWorld={dragPointWorld}
              setDragPointWorld={setDragPointWorld}
              setPointerActive={setPointerActive}
              controlsRef={controlsRef}
              pointerDownRef={pointerDownRef}
              pointerStartRef={pointerStartRef}
              setDragHeight={setDragHeight}
              sceneScale={sceneScale}
            />
          </group>
          <Ghost dragPointWorld={dragPointWorld} selectedPieceId={selectedPieceId} piecesState={piecesState} sceneScale={sceneScale} />
          <OrbitControls
            ref={controlsRef}
            makeDefault
            enablePan={false}
            enableDamping={true}
            dampingFactor={0.08}
            rotateSpeed={0.45}
            zoomSpeed={0.6}
            target={camTarget}
            onEnd={() => {
              // persist camera and target when user finishes interacting
              const c = controlsRef.current;
              if (!c) return;
              const cam = c.object;
              if (cam) {
                const pos = [cam.position.x, cam.position.y, cam.position.z];
                setCamPos(pos);
                try { localStorage.setItem('camPos', JSON.stringify(pos)); } catch {}
              }
              if (c.target) {
                const tgt = [c.target.x, c.target.y, c.target.z];
                setCamTarget(tgt);
                try { localStorage.setItem('camTarget', JSON.stringify(tgt)); } catch {}
              }
            }}
          />
        </Canvas>
      </main>
    </div>
  );
}
