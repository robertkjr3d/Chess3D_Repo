import { useState, useRef, useEffect } from "react";
import { Canvas } from "@react-three/fiber";
import { OrbitControls, useGLTF } from "@react-three/drei";
import "./App.css";

function Square({ position, color }) {
  return (
    <mesh position={position}>
      <boxGeometry args={[1, 0.15, 1]} />
      <meshStandardMaterial color={color} />
    </mesh>
  );
}

function BoardLevel({ y, flip = false }) {
  const squares = [];
  for (let x = 0; x < 8; x++) {
    for (let row = 0; row < 4; row++) {
      // within-board rows use logical y; flip so logical y=0 maps to visual top within board
      const yIndex = 3 - row;
      const isWhite = ((x + yIndex + (flip ? 1 : 0)) % 2) !== 0;
      squares.push(
        <Square
          key={`${y}-${x}-${row}`}
          // world coordinates: X, world Y (level), world Z (in-board row)
          position={[x - 3.5, y, yIndex - 3.5]}
          color={isWhite ? "#f0d9b5" : "#b58863"}
        />
      );
    }
  }
  return <group>{squares}</group>;
}

function QuadLevelBoard() {
  return (
    <group>
      <BoardLevel y={0} flip={true} />
      <BoardLevel y={3.725} flip={false} />
      <BoardLevel y={6.6} flip={true} />
      <BoardLevel y={8.75} flip={false} />
    </group>
  );
}

function Pieces({ piecesState, setPiecesState, selectedPieceId, setSelectedPieceId, isDragging, dragPoint, setIsDragging, setDragPoint }) {
  const levels = [0, 3.725, 6.6, 8.75];
  const pieces = [];

  // Load GLB models from public/models
  const kingGltf = useGLTF('/models/king2.glb');
  const pawnGltf = useGLTF('/models/pawn2.glb');
  const knightGltf = useGLTF('/models/knight_-_staunton_full_size_chess_set.glb');
  const bishopGltf = useGLTF('/models/bishop_-_staunton_full_size_chess_set.glb');
  const rookGltf = useGLTF('/models/rook_-_staunton_full_size_chess_set.glb');
  const queenGltf = useGLTF('/models/queen_-_staunton_full_size_chess_set.glb');

  // Per-piece scale constants (tweak these if models look too big/small)
  const scaleMap = {
    pawn: 0.013,
    knight: 0.013,
    bishop: 0.013,
    rook: 0.013,
    queen: 0.013,
    king: 0.013,
  };

  function cloneAndColor(gltf, color) {
    const obj = gltf.scene.clone(true);
    obj.traverse((n) => {
      if (n.isMesh) {
        if (n.material) {
          n.material = n.material.clone();
          try { n.material.color.set(color); } catch (e) {}
          n.castShadow = true;
          n.receiveShadow = true;
        }
      }
    });
    return obj;
  }

  // piecesState is an array of piece objects with {id,x,y,z,t,color}
  const allPieces = piecesState;

  // occupancy set keyed by logical coords
  const occupied = new Set(allPieces.map((p) => `${p.x},${p.y},${p.z}`));

  // helper to convert logical coords to world positions
  function worldPosFromLogical(lx, ly, lz) {
    const wx = lx - 3.5;
    const wy = levels[lz] + 0.11;
    const wz = (3 - ly) - 3.5;
    return [wx, wy, wz];
  }

  // compute legal moves for a selected white piece (pawns + knights)
  const occupiedMap = new Map(allPieces.map((p) => [`${p.x},${p.y},${p.z}`, p.color]));
  let legalMoves = [];
  if (selectedPieceId != null) {
    const sel = allPieces.find((pp) => pp.id === selectedPieceId);
    if (sel && sel.color === 'white') {
      const { x: sx, y: sy, z: sz, t: st } = sel;

      // Pawn moves (white moves toward decreasing x)
      if (st === 'p') {
        const oneX = sx - 1;
        const twoX = sx - 2;
        if (oneX >= 0 && !occupiedMap.has(`${oneX},${sy},${sz}`)) {
          legalMoves.push({ x: oneX, y: sy, z: sz });
          if (sx === 6 && twoX >= 0 && !occupiedMap.has(`${twoX},${sy},${sz}`)) {
            legalMoves.push({ x: twoX, y: sy, z: sz });
          }
        }
      }

      // Knight moves in 3D: all permutations of (2,1,0) across axes with sign combos
      if (st === 'N') {
        const perms = [
          [2, 1, 0], [2, 0, 1], [1, 2, 0], [1, 0, 2], [0, 2, 1], [0, 1, 2],
        ];
        const moveSet = new Set();
        perms.forEach(([ax, ay, az]) => {
          const xs = ax === 0 ? [0] : [-ax, ax];
          const ys = ay === 0 ? [0] : [-ay, ay];
          const zs = az === 0 ? [0] : [-az, az];
          xs.forEach((dx) => ys.forEach((dy) => zs.forEach((dz) => {
            const nx = sx + dx;
            const ny = sy + dy;
            const nz = sz + dz;
            // bounds: x in 0..7, y in 0..3, z in 0..3
            if (nx < 0 || nx > 7 || ny < 0 || ny > 3 || nz < 0 || nz > 3) return;
            const key = `${nx},${ny},${nz}`;
            // can't land on own piece
            if (occupiedMap.get(key) === 'white') return;
            moveSet.add(key);
          })));
        });
        moveSet.forEach((k) => {
          const [x, y, z] = k.split(',').map(Number);
          legalMoves.push({ x, y, z });
        });
      }
    }
  }

  // render all pieces
  allPieces.forEach((p, idx) => {
    const world = worldPosFromLogical(p.x, p.y, p.z);
    const modelMap = {
      R: rookGltf,
      N: knightGltf,
      B: bishopGltf,
      K: kingGltf,
      Q: queenGltf,
      p: pawnGltf,
    };
    const gltf = modelMap[p.t] || pawnGltf;
    const pieceNameMap = { N: 'knight', B: 'bishop', K: 'king', Q: 'queen' };
    const s = scaleMap[pieceNameMap[p.t] || 'pawn'];

    // clickable group for white pawns and knights
    const isWhite = p.color === 'white';
    const isSelected = selectedPieceId === p.id;
    const pos = isSelected && isDragging ? dragPoint : world;
    pieces.push(
      <group
        key={`${p.id}-${p.t}-${idx}`}
        position={pos}
        onPointerDown={(e) => {
          e.stopPropagation();
          if ((p.t === 'p' || p.t === 'N') && isWhite) {
            setSelectedPieceId(p.id);
            // start dragging
            setIsDragging(true);
            if (e && e.point) setDragPoint([e.point.x, e.point.y, e.point.z]);
          } else {
            setSelectedPieceId(null);
          }
        }}
        onPointerUp={(e) => {
          e.stopPropagation();
          // stop dragging when pointer up on piece (no move)
          setIsDragging(false);
        }}
      >
        <primitive
          object={cloneAndColor(gltf, isWhite ? '#ffffff' : '#615c5c')}
          scale={s}
          rotation={isWhite ? [0, Math.PI, 0] : [0, 0, 0]}
        />
      </group>
    );
  });

  // render move indicators (red dots)
  function moveTo(target) {
    if (selectedPieceId == null) return;
    setPiecesState((prev) => {
      // remove any black piece at target (capture)
      const withoutCaptured = prev.filter(
        (pp) => !(pp.x === target.x && pp.y === target.y && pp.z === target.z && pp.color === 'black')
      );
      // move the selected piece
      return withoutCaptured.map((pp) =>
        pp.id === selectedPieceId ? { ...pp, x: target.x, y: target.y, z: target.z } : pp
      );
    });
    setSelectedPieceId(null);
  }

  const indicators = legalMoves.map((m, i) => {
    const wp = worldPosFromLogical(m.x, m.y, m.z);
    return (
      <mesh key={`move-ind-${i}`} position={wp} onPointerUp={(e) => { e.stopPropagation(); moveTo(m); }}>
        <sphereGeometry args={[0.14, 16, 16]} />
        <meshStandardMaterial color="#ff0000" />
      </mesh>
    );
  });

  return <group>{pieces.concat(indicators)}</group>;
}

export default function App() {
  const [aiSide, setAiSide] = useState(null);
  const [selectedPieceId, setSelectedPieceId] = useState(null);
  const [isDragging, setIsDragging] = useState(false);
  const [dragPoint, setDragPoint] = useState([0, 0, 0]);

  // build initial pieces list (logical coords)
  function getInitialPieces() {
    const levels = [0, 1, 2, 3]; // logical levels
    const res = [];
    let id = 1;
    levels.forEach((lz) => {
      for (let row = 0; row < 4; row++) {
        res.push({ id: id++, x: 1, y: row, z: lz, t: 'p', color: 'black' });
        res.push({ id: id++, x: 6, y: row, z: lz, t: 'p', color: 'white' });
      }
    });

    const placements = [
      { x: 0, y: 0, z: 0, t: 'R' },
      { x: 0, y: 1, z: 0, t: 'N' },
      { x: 0, y: 2, z: 0, t: 'B' },
      { x: 0, y: 3, z: 0, t: 'R' },
      { x: 0, y: 0, z: 1, t: 'B' },
      { x: 0, y: 1, z: 1, t: 'K' },
      { x: 0, y: 2, z: 1, t: 'Q' },
      { x: 0, y: 3, z: 1, t: 'N' },
      { x: 0, y: 0, z: 2, t: 'N' },
      { x: 0, y: 1, z: 2, t: 'Q' },
      { x: 0, y: 2, z: 2, t: 'K' },
      { x: 0, y: 3, z: 2, t: 'B' },
      { x: 0, y: 0, z: 3, t: 'R' },
      { x: 0, y: 1, z: 3, t: 'B' },
      { x: 0, y: 2, z: 3, t: 'N' },
      { x: 0, y: 3, z: 3, t: 'R' },
    ];
    placements.forEach((p) => {
      res.push({ id: id++, x: p.x, y: p.y, z: p.z, t: p.t, color: 'black' });
      res.push({ id: id++, x: 7 - p.x, y: p.y, z: p.z, t: p.t, color: 'white' });
    });
    return res;
  }

  const [piecesState, setPiecesState] = useState(() => getInitialPieces());

  // camera / controls persistence
  const controlsRef = useRef();
  // prefer explicit saved defaults if present; otherwise fall back to last-used camPos
  const [camPos, setCamPos] = useState(() => {
    try {
      return JSON.parse(localStorage.getItem('camDefaultPos')) || JSON.parse(localStorage.getItem('camPos')) || [6, 5, -8];
    } catch { return [6,5,-8]; }
  });
  const [camTarget, setCamTarget] = useState(() => {
    try {
      return JSON.parse(localStorage.getItem('camDefaultTarget')) || JSON.parse(localStorage.getItem('camTarget')) || [0, 1.7, 0];
    } catch { return [0,1.7,0]; }
  });

  useEffect(() => {
    // apply saved target to controls when they mount
    if (controlsRef.current) {
      const c = controlsRef.current;
      if (c.target && Array.isArray(camTarget)) {
        c.target.set(camTarget[0], camTarget[1], camTarget[2]);
        c.update();
      }
      // ensure camera position if accessible
      if (c.object && Array.isArray(camPos)) {
        c.object.position.set(camPos[0], camPos[1], camPos[2]);
      }
    }
  }, [controlsRef, camPos, camTarget]);



  return (
    <div className="layout">
      <aside className="sidebar">
        <h2 className="title">Quadlevel 3D Chess</h2>
        <div className="menu">
          <button className="menu-button" onClick={() => setAiSide('white')}>
            Play AI White
          </button>
          <button className="menu-button" onClick={() => setAiSide('black')}>
            Play AI Black
          </button>
        </div>
        {aiSide && <div className="status">AI playing: {aiSide}</div>}
      </aside>
      <main className="main">
        <Canvas
          className="canvas"
          camera={{ position: camPos, fov: 32 }}
          onPointerMove={(e) => {
            if (isDragging && e.point) setDragPoint([e.point.x, e.point.y, e.point.z]);
          }}
        >
          <ambientLight intensity={0.6} />
          <directionalLight position={[5, 12, 5]} intensity={0.9} />
          <group scale={0.470}>
            <QuadLevelBoard />
            <Pieces
              piecesState={piecesState}
              setPiecesState={setPiecesState}
              selectedPieceId={selectedPieceId}
              setSelectedPieceId={setSelectedPieceId}
              isDragging={isDragging}
              dragPoint={dragPoint}
              setIsDragging={setIsDragging}
              setDragPoint={setDragPoint}
            />
          </group>
          <OrbitControls
            ref={controlsRef}
            makeDefault
            enablePan={false}
            enableDamping={true}
            dampingFactor={0.08}
            rotateSpeed={0.45}
            zoomSpeed={0.6}
            target={camTarget}
            onEnd={() => {
              // persist camera and target when user finishes interacting
              const c = controlsRef.current;
              if (!c) return;
              const cam = c.object;
              if (cam) {
                const pos = [cam.position.x, cam.position.y, cam.position.z];
                setCamPos(pos);
                try { localStorage.setItem('camPos', JSON.stringify(pos)); } catch {}
              }
              if (c.target) {
                const tgt = [c.target.x, c.target.y, c.target.z];
                setCamTarget(tgt);
                try { localStorage.setItem('camTarget', JSON.stringify(tgt)); } catch {}
              }
            }}
          />
        </Canvas>
      </main>
    </div>
  );
}
