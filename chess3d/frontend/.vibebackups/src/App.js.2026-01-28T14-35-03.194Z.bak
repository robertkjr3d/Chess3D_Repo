import { useState, useRef, useEffect, useMemo, useCallback } from "react";
import * as THREE from 'three';
import { Canvas, useThree, useFrame } from "@react-three/fiber";
import { OrbitControls, useGLTF } from "@react-three/drei";
import "./App.css";

const GLOBAL_PIECE_SCALE = {
  pawn: 0.013,
  knight: 0.013,
  bishop: 0.013,
  rook: 0.013,
  queen: 0.013,
  king: 0.013,
};
const GHOST_SCALE_FACTOR = 1.0;

    function Square({ position, color }) {
      return (
        <mesh position={position}>
          <boxGeometry args={[1, 0.15, 1]} />
          <meshStandardMaterial color={color} />
        </mesh>
      );
    }

    function BoardLevel({ y, flip = false }) {
      const squares = [];
      for (let x = 0; x < 8; x++) {
        for (let row = 0; row < 4; row++) {
          // within-board rows use logical y; flip so logical y=0 maps to visual top within board
          const yIndex = 3 - row;
          const isWhite = ((x + yIndex + (flip ? 1 : 0)) % 2) !== 0;
          squares.push(
            <Square
              key={`${y}-${x}-${row}`}
              // world coordinates: X, world Y (level), world Z (in-board row)
              position={[x - 3.5, y, yIndex - 3.5]}
              color={isWhite ? "#f0d9b5" : "#b58863"}
            />
          );
        }
      }
      return <group>{squares}</group>;
    }

    function QuadLevelBoard() {
      return (
        <group>
          <BoardLevel y={0} flip={true} />
          <BoardLevel y={3.725} flip={false} />
          <BoardLevel y={6.6} flip={true} />
          <BoardLevel y={8.75} flip={false} />
        </group>
      );
    }

    function Pieces({ piecesState, setPiecesState, selectedPieceId, setSelectedPieceId, isDragging, dragPoint, setIsDragging, setDragPoint, dragPointWorld, setDragPointWorld, setPointerActive, controlsRef, pointerDownRef, pointerStartRef, pointerStartScreenRef, pendingDrop, setPendingDrop, groupRef, setDragHeight, sceneScale }) {
      const levels = [0, 3.725, 6.6, 8.75];
      const pieces = [];

      // Load GLB models from public/models
      const kingGltf = useGLTF('/models/king2.glb');
      const pawnGltf = useGLTF('/models/pawn2.glb');
      const knightGltf = useGLTF('/models/knight_-_staunton_full_size_chess_set.glb');
      const bishopGltf = useGLTF('/models/bishop_-_staunton_full_size_chess_set.glb');
      const rookGltf = useGLTF('/models/rook_-_staunton_full_size_chess_set.glb');
      const queenGltf = useGLTF('/models/queen_-_staunton_full_size_chess_set.glb');

      // Per-piece scale constants (tweak these if models look too big/small)
      const scaleMap = GLOBAL_PIECE_SCALE;

      function cloneAndColor(gltf, color) {
        const obj = gltf.scene.clone(true);
        obj.traverse((n) => {
          if (n.isMesh) {
            if (n.material) {
              n.material = n.material.clone();
              try { n.material.color.set(color); } catch (e) {}
              n.castShadow = true;
              n.receiveShadow = true;
            }
          }
        });
        return obj;
      }

      // piecesState is an array of piece objects with {id,x,y,z,t,color}
      const allPieces = piecesState;

      // occupancy set keyed by logical coords (unused currently)

      // helper to convert logical coords to world positions
      function worldPosFromLogical(lx, ly, lz) {
        const wx = lx - 3.5;
        const wy = levels[lz] + 0.11;
        const wz = (3 - ly) - 3.5;
        return [wx, wy, wz];
      }

      // compute legal moves for a selected white piece (pawns + knights)
      const legalMoves = useMemo(() => {
        const occupiedMap = new Map(allPieces.map((p) => [`${p.x},${p.y},${p.z}`, p.color]));
        const moves = [];
        if (selectedPieceId == null) return moves;
        const sel = allPieces.find((pp) => pp.id === selectedPieceId);
        if (!sel || sel.color !== 'white') return moves;
        const { x: sx, y: sy, z: sz, t: st } = sel;
        if (st === 'p') {
          const oneX = sx - 1;
          const twoX = sx - 2;
          if (oneX >= 0 && !occupiedMap.has(`${oneX},${sy},${sz}`)) {
            moves.push({ x: oneX, y: sy, z: sz });
            if (sx === 6 && twoX >= 0 && !occupiedMap.has(`${twoX},${sy},${sz}`)) {
              moves.push({ x: twoX, y: sy, z: sz });
            }
          }
        }
        if (st === 'N') {
          // Knight moves allowed only in X-Y (dz=0) or X-Z (dy=0) planes
          const perms = [[2, 1, 0], [1, 2, 0], [2, 0, 1], [1, 0, 2]];
          const moveSet = new Set();
          perms.forEach(([ax, ay, az]) => {
            const xs = ax === 0 ? [0] : [-ax, ax];
            const ys = ay === 0 ? [0] : [-ay, ay];
            const zs = az === 0 ? [0] : [-az, az];
            xs.forEach((dx) => ys.forEach((dy) => zs.forEach((dz) => {
              // enforce plane constraint: either dz===0 (XY move) or dy===0 (XZ move)
              if (!(dz === 0 || dy === 0)) return;
              const nx = sx + dx;
              const ny = sy + dy;
              const nz = sz + dz;
              if (nx < 0 || nx > 7 || ny < 0 || ny > 3 || nz < 0 || nz > 3) return;
              const key = `${nx},${ny},${nz}`;
              if (occupiedMap.get(key) === 'white') return;
              moveSet.add(key);
            })));
          });
          moveSet.forEach((k) => {
            const [x, y, z] = k.split(',').map(Number);
            moves.push({ x, y, z });
          });
        }
        return moves;
      }, [allPieces, selectedPieceId]);

      // render all pieces
      allPieces.forEach((p, idx) => {
        const world = worldPosFromLogical(p.x, p.y, p.z);
        const modelMap = {
          R: rookGltf,
          N: knightGltf,
          B: bishopGltf,
          K: kingGltf,
          Q: queenGltf,
          p: pawnGltf,
        };
        const gltf = modelMap[p.t] || pawnGltf;
        const pieceNameMap = { N: 'knight', B: 'bishop', K: 'king', Q: 'queen' };
        const s = scaleMap[pieceNameMap[p.t] || 'pawn'];

        // clickable group for white pawns and knights
        const isWhite = p.color === 'white';
        const isSelected = selectedPieceId === p.id;
        // When selected and actively dragging, render the piece at the computed local `dragPoint`
        const pos = isSelected && isDragging ? dragPoint : world;
        const visible = !(isSelected && isDragging);
        pieces.push(
          <group
            key={`${p.id}-${p.t}-${idx}`}
            position={pos}
            visible={visible}
                onPointerDown={(e) => {
              e.stopPropagation();
              try { if (pointerStartScreenRef) pointerStartScreenRef.current = { x: e.clientX, y: e.clientY }; } catch {}
              // toggle selection when clicking same piece
                if ((p.t === 'p' || p.t === 'N') && isWhite) {
                if (selectedPieceId === p.id) {
                  // toggle off selection, but keep controls disabled until pointer up
                  setSelectedPieceId(null);
                  pointerDownRef.current = false;
                  pointerStartRef.current = null;
                  try { if (setPointerActive) setPointerActive(true); } catch {}
                  return;
                }
                setSelectedPieceId(p.id);
                // record pointer-down start and initial drag height; don't start dragging yet
                pointerDownRef.current = true;
                pointerStartRef.current = e.point || null;
                // convert initial world pos into group's local coords so ghost appears at same place
                if (groupRef.current) {
                  try {
                    const lv = new THREE.Vector3(world[0], world[1], world[2]);
                    groupRef.current.worldToLocal(lv);
                    setDragPoint([lv.x, lv.y, lv.z]);
                  } catch (err) {
                    setDragPoint(world);
                  }
                } else {
                  setDragPoint([world[0] / sceneScale, world[1], world[2] / sceneScale]);
                }
                setDragHeight(world[1]);
                    try { if (setDragPointWorld) setDragPointWorld([e.point.x, e.point.y, e.point.z]); } catch {}
                    try { if (setPointerActive) setPointerActive(true); } catch {}
                // immediately disable OrbitControls so the board doesn't move while attempting drag
                try { if (controlsRef.current) controlsRef.current.enabled = false; } catch {}
              } else {
                setSelectedPieceId(null);
              }
            }}
          >
            <primitive
              object={cloneAndColor(gltf, isWhite ? '#ffffff' : '#615c5c')}
              scale={s}
              rotation={isWhite ? [0, Math.PI, 0] : [0, 0, 0]}
            />
          </group>
        );
      });

      // render move indicators (red dots)
      const moveTo = useCallback((target) => {
        if (selectedPieceId == null) return;
        setPiecesState((prev) => {
          const withoutCaptured = prev.filter(
            (pp) => !(pp.x === target.x && pp.y === target.y && pp.z === target.z && pp.color === 'black')
          );
          return withoutCaptured.map((pp) =>
            pp.id === selectedPieceId ? { ...pp, x: target.x, y: target.y, z: target.z } : pp
          );
        });
        setSelectedPieceId(null);
      }, [selectedPieceId, setPiecesState, setSelectedPieceId]);

      // when App reports a pendingDrop, decide whether it's a legal landing square
      useEffect(() => {
        if (!pendingDrop) return;
        if (selectedPieceId == null) {
          setPendingDrop(null);
          return;
        }
        try {
          // convert world point to local coords
          const v = new THREE.Vector3(pendingDrop[0], pendingDrop[1], pendingDrop[2]);
          if (groupRef && groupRef.current) groupRef.current.worldToLocal(v);
          // determine nearest logical coords
          const lx = Math.round(v.x + 3.5);
          const ly = Math.round(3 - (v.z + 3.5));
          // pick level by closest Y
          const levels = [0, 3.725, 6.6, 8.75];
          let lz = 0;
          let bestDist = Infinity;
          for (let i = 0; i < levels.length; i++) {
            const d = Math.abs(v.y - (levels[i] + 0.11));
            if (d < bestDist) { bestDist = d; lz = i; }
          }
          const key = `${lx},${ly},${lz}`;
          const legalSet = new Set(legalMoves.map(m => `${m.x},${m.y},${m.z}`));
          if (legalSet.has(key)) {
            moveTo({ x: lx, y: ly, z: lz });
          } else {
            // cancel drag: clear selection and leave piecesState unchanged
            setSelectedPieceId(null);
          }
        } catch (e) {}
        setPendingDrop(null);
        // ensure dragging state cleared
        try { if (controlsRef && controlsRef.current) controlsRef.current.enabled = true; } catch {}
        try { pointerDownRef.current = false; } catch {}
        setIsDragging(false);
        setDragPointWorld(null);
        setPointerActive(false);
      }, [pendingDrop, controlsRef, groupRef, /*legalMoves*/ legalMoves, moveTo, pointerDownRef, selectedPieceId, setDragPointWorld, setIsDragging, setPendingDrop, setPointerActive, setSelectedPieceId]);

      const indicators = legalMoves.map((m, i) => {
        const wp = worldPosFromLogical(m.x, m.y, m.z);
        return (
          <mesh key={`move-ind-${i}`} position={wp} onPointerUp={(e) => { e.stopPropagation(); moveTo(m); try { if (controlsRef.current) controlsRef.current.enabled = true; } catch{} }}>
            <sphereGeometry args={[0.14, 16, 16]} />
            <meshStandardMaterial color="#ff0000" />
          </mesh>
        );
      });

      return <group>{pieces.concat(indicators)}</group>;
    }

    function Ghost({ dragPointWorld, selectedPieceId, piecesState, isDragging, pointerDownRef }) {
      const spriteRef = useRef();
      const { camera, size } = useThree();
      useFrame(() => {
        if (!spriteRef.current || !dragPointWorld) return;
        const pos = new THREE.Vector3(dragPointWorld[0], dragPointWorld[1], dragPointWorld[2]);
        spriteRef.current.position.copy(pos);
        const desiredPx = 48; // target pixel size for ghost
        const distance = camera.position.distanceTo(pos);
        const vFOV = (camera.fov * Math.PI) / 180;
        const worldHeightAtDistance = 2 * Math.tan(vFOV / 2) * distance;
        const worldSize = (desiredPx / size.height) * worldHeightAtDistance;
        spriteRef.current.scale.set(worldSize, worldSize, 1);
      });

      const pointerDown = !!(pointerDownRef && pointerDownRef.current);
      if (!dragPointWorld || selectedPieceId == null || !(isDragging || pointerDown)) return null;
      const sel = piecesState.find((p) => p.id === selectedPieceId);
      if (!sel) return null;
      const color = sel.color === 'white' ? '#ffffff' : '#615c5c';

      return (
        <group raycast={() => null} renderOrder={999}>
          <sprite ref={spriteRef}>
            <spriteMaterial color={color} transparent opacity={0.85} depthTest={false} depthWrite={false} />
          </sprite>
        </group>
      );
    }

    export default function App() {
      const [aiSide, setAiSide] = useState(null);
      const [selectedPieceId, setSelectedPieceId] = useState(null);
      const [isDragging, setIsDragging] = useState(false);
      const [dragPoint, setDragPoint] = useState([0, 0, 0]);
      const [dragHeight, setDragHeight] = useState(0);
      const [dragPointWorld, setDragPointWorld] = useState(null);
      const [pendingDrop, setPendingDrop] = useState(null);
      const [pointerActive, setPointerActive] = useState(false);
      const pointerDownRef = useRef(false);
      const pointerStartRef = useRef(null);
      const pointerStartScreenRef = useRef(null);
      const groupRef = useRef();
      const sceneScale = 0.470;
      

      // build initial pieces list (logical coords)
      function getInitialPieces() {
        const levels = [0, 1, 2, 3]; // logical levels
        const res = [];
        let id = 1;
        levels.forEach((lz) => {
          for (let row = 0; row < 4; row++) {
            res.push({ id: id++, x: 1, y: row, z: lz, t: 'p', color: 'black' });
            res.push({ id: id++, x: 6, y: row, z: lz, t: 'p', color: 'white' });
          }
        });

        const placements = [
          { x: 0, y: 0, z: 0, t: 'R' },
          { x: 0, y: 1, z: 0, t: 'N' },
          { x: 0, y: 2, z: 0, t: 'B' },
          { x: 0, y: 3, z: 0, t: 'R' },
          { x: 0, y: 0, z: 1, t: 'B' },
          { x: 0, y: 1, z: 1, t: 'K' },
          { x: 0, y: 2, z: 1, t: 'Q' },
          { x: 0, y: 3, z: 1, t: 'N' },
          { x: 0, y: 0, z: 2, t: 'N' },
          { x: 0, y: 1, z: 2, t: 'Q' },
          { x: 0, y: 2, z: 2, t: 'K' },
          { x: 0, y: 3, z: 2, t: 'B' },
          { x: 0, y: 0, z: 3, t: 'R' },
          { x: 0, y: 1, z: 3, t: 'B' },
          { x: 0, y: 2, z: 3, t: 'N' },
          { x: 0, y: 3, z: 3, t: 'R' },
        ];
        placements.forEach((p) => {
          res.push({ id: id++, x: p.x, y: p.y, z: p.z, t: p.t, color: 'black' });
          res.push({ id: id++, x: 7 - p.x, y: p.y, z: p.z, t: p.t, color: 'white' });
        });
        return res;
      }

      const [piecesState, setPiecesState] = useState(() => getInitialPieces());

      // camera / controls persistence
      const controlsRef = useRef();
      // prefer explicit saved defaults if present; otherwise fall back to last-used camPos
      const [camPos, setCamPos] = useState(() => {
        try {
          return JSON.parse(localStorage.getItem('camDefaultPos')) || JSON.parse(localStorage.getItem('camPos')) || [6, 5, -8];
        } catch { return [6,5,-8]; }
      });
      const [camTarget, setCamTarget] = useState(() => {
        try {
          return JSON.parse(localStorage.getItem('camDefaultTarget')) || JSON.parse(localStorage.getItem('camTarget')) || [0, 1.7, 0];
        } catch { return [0,1.7,0]; }
      });

      useEffect(() => {
        // apply saved target to controls when they mount
        if (controlsRef.current) {
          const c = controlsRef.current;
          if (c.target && Array.isArray(camTarget)) {
            c.target.set(camTarget[0], camTarget[1], camTarget[2]);
            c.update();
          }
          // ensure camera position if accessible
          if (c.object && Array.isArray(camPos)) {
            c.object.position.set(camPos[0], camPos[1], camPos[2]);
          }
        }
      }, [controlsRef, camPos, camTarget]);

      // keep OrbitControls enabled state in sync with pointer interaction/dragging
      useEffect(() => {
        try {
          if (controlsRef.current) {
            controlsRef.current.enabled = !pointerActive && !isDragging;
          }
        } catch (e) {}
      }, [pointerActive, isDragging, controlsRef]);



      return (
        <div className="layout">
          <aside className="sidebar">
            <h2 className="title">Quadlevel 3D Chess</h2>
            <div className="menu">
              <button className="menu-button" onClick={() => setAiSide('white')}>
                Play AI White
              </button>
              <button className="menu-button" onClick={() => setAiSide('black')}>
                Play AI Black
              </button>
            </div>
            {aiSide && <div className="status">AI playing: {aiSide}</div>}
          </aside>
          <main className="main">
            <Canvas
              className="canvas"
              camera={{ position: camPos, fov: 32 }}
              onPointerMove={(e) => {
                // if pointer was pressed on a piece and user moved enough (screen-space), start dragging
                if (pointerDownRef.current && !isDragging && selectedPieceId != null && pointerStartScreenRef.current) {
                  const dx = e.clientX - pointerStartScreenRef.current.x;
                  const dy = e.clientY - pointerStartScreenRef.current.y;
                  const dist = Math.hypot(dx, dy);
                  // pixel threshold for consistent drag start across depths
                  if (dist > 6) {
                    setIsDragging(true);
                    try { if (controlsRef.current) controlsRef.current.enabled = false; } catch {}
                  }
                }
                // update drag point while pointer is down (so piece follows cursor immediately) or when dragging
                if (pointerDownRef.current || isDragging) {
                  // compute world point for ghost: prefer e.point (hit), otherwise raycast from camera to horizontal plane at dragHeight
                  let worldPoint = null;
                  if (e.point) {
                    worldPoint = new THREE.Vector3(e.point.x, e.point.y, e.point.z);
                  } else {
                    try {
                      const canvas = document.querySelector('canvas');
                      if (canvas) {
                        const rect = canvas.getBoundingClientRect();
                        const x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                        const y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
                        const cam = controlsRef.current && controlsRef.current.object;
                        if (cam) {
                          const ndc = new THREE.Vector2(x, y);
                          const raycaster = new THREE.Raycaster();
                          raycaster.setFromCamera(ndc, cam);
                          const ro = raycaster.ray.origin;
                          const rd = raycaster.ray.direction;
                          const planeY = dragHeight;
                          if (Math.abs(rd.y) > 1e-6) {
                            const t = (planeY - ro.y) / rd.y;
                            // require forward hit and reasonable distance
                            if (t > 0.001 && t < 200) {
                              worldPoint = new THREE.Vector3().copy(rd).multiplyScalar(t).add(ro);
                            }
                          }
                        }
                      }
                    } catch (err) {}
                  }

                  if (worldPoint) {
                    setDragPointWorld([worldPoint.x, worldPoint.y, worldPoint.z]);
                    if (groupRef.current) {
                      const v = worldPoint.clone();
                      groupRef.current.worldToLocal(v);
                      // use the transformed local y directly and add small offset to avoid z-fighting
                      v.y = v.y + 0.02;
                      setDragPoint([v.x, v.y, v.z]);
                    } else {
                      setDragPoint([worldPoint.x / sceneScale, dragHeight + 0.02, worldPoint.z / sceneScale]);
                    }
                  }
                }
              }}
              onPointerUp={(e) => {
                // if we were dragging, send the last world point for drop processing
                if (isDragging && dragPointWorld) {
                  setPendingDrop(dragPointWorld);
                }
                // release drag anywhere
                pointerDownRef.current = false;
                pointerStartRef.current = null;
                try { pointerStartScreenRef.current = null; } catch {}
                setIsDragging(false);
                setDragPointWorld(null);
                setPointerActive(false);
                // always re-enable controls on pointer up
                try { if (controlsRef.current) controlsRef.current.enabled = true; } catch {}
              }}
            >
              <ambientLight intensity={0.6} />
              <directionalLight position={[5, 12, 5]} intensity={0.9} />
              <group ref={groupRef} scale={sceneScale}>
                <QuadLevelBoard />
                <Pieces
                  piecesState={piecesState}
                  setPiecesState={setPiecesState}
                  selectedPieceId={selectedPieceId}
                  setSelectedPieceId={setSelectedPieceId}
                  isDragging={isDragging}
                  dragPoint={dragPoint}
                  setIsDragging={setIsDragging}
                  setDragPoint={setDragPoint}
                  dragPointWorld={dragPointWorld}
                  setDragPointWorld={setDragPointWorld}
                  setPointerActive={setPointerActive}
                  controlsRef={controlsRef}
                  pointerDownRef={pointerDownRef}
                  pointerStartRef={pointerStartRef}
                  pointerStartScreenRef={pointerStartScreenRef}
                  pendingDrop={pendingDrop}
                  setPendingDrop={setPendingDrop}
                  groupRef={groupRef}
                  setDragHeight={setDragHeight}
                  sceneScale={sceneScale}
                />
                </group>
                <Ghost dragPointWorld={dragPointWorld} selectedPieceId={selectedPieceId} piecesState={piecesState} isDragging={isDragging} pointerDownRef={pointerDownRef} />
                {/* Debug marker: small red sphere at computed world intersection (visible while pointer active) */}
                {dragPointWorld && (
                  <mesh position={dragPointWorld}>
                    <sphereGeometry args={[0.08, 12, 12]} />
                    <meshStandardMaterial color="#ff0000" />
                  </mesh>
                )}
              <OrbitControls
                ref={controlsRef}
                makeDefault
                enablePan={false}
                enableDamping={true}
                dampingFactor={0.08}
                rotateSpeed={0.45}
                zoomSpeed={0.6}
                target={camTarget}
                onEnd={() => {
                  // persist camera and target when user finishes interacting
                  const c = controlsRef.current;
                  if (!c) return;
                  const cam = c.object;
                  if (cam) {
                    const pos = [cam.position.x, cam.position.y, cam.position.z];
                    setCamPos(pos);
                    try { localStorage.setItem('camPos', JSON.stringify(pos)); } catch {}
                  }
                  if (c.target) {
                    const tgt = [c.target.x, c.target.y, c.target.z];
                    setCamTarget(tgt);
                    try { localStorage.setItem('camTarget', JSON.stringify(tgt)); } catch {}
                  }
                }}
              />
            </Canvas>
          </main>
        </div>
      );
    }
//                setCamTarget(tgt);
  //              try { localStorage.setItem('camTarget', JSON.stringify(tgt)); } catch {}
    //          }
      //      }}
        //  />
        //</Canvas>
      //</main>
    //</div>
  //);
//}
