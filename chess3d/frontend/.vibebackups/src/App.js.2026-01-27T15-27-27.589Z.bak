import { useState } from "react";
import { Canvas } from "@react-three/fiber";
import { OrbitControls } from "@react-three/drei";
import "./App.css";

function Square({ position, color }) {
  return (
    <mesh position={position}>
      <boxGeometry args={[1, 0.15, 1]} />
      <meshStandardMaterial color={color} />
    </mesh>
  );
}

function BoardLevel({ y, flip = false }) {
  const squares = [];
  for (let x = 0; x < 8; x++) {
    for (let z = 0; z < 4; z++) {
      const isWhite = ((x + z + (flip ? 1 : 0)) % 2) === 0;
      squares.push(
        <Square
          key={`${y}-${x}-${z}`}
          position={[x - 3.5, y, z - 3.5]}
          color={isWhite ? "#f0d9b5" : "#b58863"}
        />
      );
    }
  }
  return <group>{squares}</group>;
}

function QuadLevelBoard() {
  return (
    <group>
      <BoardLevel y={0} flip={true} />
      <BoardLevel y={3.725} flip={false} />
      <BoardLevel y={6.6} flip={true} />
      <BoardLevel y={8.75} flip={false} />
    </group>
  );
}

function Pieces() {
  const levels = [0, 3.725, 6.6, 8.75];
  const pieces = [];

  levels.forEach((y, li) => {
    // New coordinate convention: black is on the left (low x), white on the right (high x).
    // Pawns: black pawns at x=1 across all levels and z columns; white pawns mirrored at x=6.
    for (let z = 0; z < 4; z++) {
      const blackX = 1 - 3.5;
      const whiteX = 6 - 3.5;
      const wy = y + 0.35;
      const wz = z - 3.5;

      pieces.push(
        <mesh key={`b-pawn-${li}-${z}`} position={[blackX, wy, wz]}>
          <sphereGeometry args={[0.35, 16, 12]} />
          <meshStandardMaterial color="#222222" />
        </mesh>
      );

      pieces.push(
        <mesh key={`w-pawn-${li}-${z}`} position={[whiteX, wy, wz]}>
          <sphereGeometry args={[0.35, 16, 12]} />
          <meshStandardMaterial color="#ffffff" />
        </mesh>
      );
    }

    // Place specific black-piece placements on the left (x=0) as provided,
    // and mirror them to the right (x=7) for white.
    function geomFor(t) {
      if (t === 'N') return <coneGeometry args={[0.35, 0.9, 12]} />;
      if (t === 'B') return <cylinderGeometry args={[0.28, 0.28, 0.9, 12]} />;
      if (t === 'K') return <cylinderGeometry args={[0.32, 0.32, 1.0, 16]} />;
      if (t === 'Q') return <cylinderGeometry args={[0.34, 0.34, 1.1, 16]} />;
      return <sphereGeometry args={[0.35, 16, 12]} />;
    }

    const placements = [
      { x: 0, y: 1, z: 0, t: 'N' },
      { x: 0, y: 2, z: 0, t: 'B' },
      { x: 0, y: 0, z: 1, t: 'B' },
      { x: 0, y: 1, z: 1, t: 'K' },
      { x: 0, y: 2, z: 1, t: 'Q' },
      { x: 0, y: 3, z: 1, t: 'N' },
      { x: 0, y: 0, z: 2, t: 'N' },
      { x: 0, y: 1, z: 2, t: 'K' },
      { x: 0, y: 2, z: 2, t: 'Q' },
      { x: 0, y: 3, z: 2, t: 'B' },
      { x: 0, y: 1, z: 3, t: 'B' },
      { x: 0, y: 2, z: 3, t: 'N' },
    ];

    placements.forEach((p, idx) => {
      if (p.y === li) {
        const bx = p.x - 3.5;
        const by = y + 0.45;
        const bz = p.z - 3.5;

        pieces.push(
          <mesh key={`b-${p.t.toLowerCase()}-${li}-${idx}`} position={[bx, by, bz]}>
            {geomFor(p.t)}
            <meshStandardMaterial color="#222222" />
          </mesh>
        );

        const mx = 7 - p.x - 3.5;
        pieces.push(
          <mesh key={`w-${p.t.toLowerCase()}-${li}-${idx}`} position={[mx, by, bz]} rotation={[0, Math.PI, 0]}>
            {geomFor(p.t)}
            <meshStandardMaterial color="#ffffff" />
          </mesh>
        );
      }
    });

    // Place rooks on specified coordinates (x0,y0,z0), (x0,y3,z0), (x0,y0,z3), (x0,y3,z3)
    // These are black (left); mirror to place white rooks on the right side (x=7).
    const rookYs = [0, 3];
    const rookZs = [0, 3];
    if (rookYs.includes(li)) {
      rookZs.forEach((rz, idx) => {
        const bx = 0 - 3.5;
        const wy = y + 0.45;
        const wz = rz - 3.5;
        pieces.push(
          <mesh key={`b-rook-${li}-${idx}`} position={[bx, wy, wz]}>
            <boxGeometry args={[0.6, 0.9, 0.6]} />
            <meshStandardMaterial color="#222222" />
          </mesh>
        );

        const wx = 7 - 0 - 3.5; // mirror x
        pieces.push(
          <mesh key={`w-rook-${li}-${idx}`} position={[wx, wy, wz]} rotation={[0, Math.PI, 0]}>
            <boxGeometry args={[0.6, 0.9, 0.6]} />
            <meshStandardMaterial color="#ffffff" />
          </mesh>
        );
      });
    }
  });

  return <group>{pieces}</group>;
}

export default function App() {
  const [aiSide, setAiSide] = useState(null);

  return (
    <div className="layout">
      <aside className="sidebar">
        <h2 className="title">Quadlevel 3D Chess</h2>
        <div className="menu">
          <button className="menu-button" onClick={() => setAiSide('white')}>
            Play AI White
          </button>
          <button className="menu-button" onClick={() => setAiSide('black')}>
            Play AI Black
          </button>
        </div>
        {aiSide && <div className="status">AI playing: {aiSide}</div>}
      </aside>
      <main className="main">
        <Canvas className="canvas" camera={{ position: [6, 5, -8], fov: 32 }}>
          <ambientLight intensity={0.6} />
          <directionalLight position={[5, 12, 5]} intensity={0.9} />
          <group scale={0.470}>
            <QuadLevelBoard />
            <Pieces />
          </group>
          <OrbitControls
            makeDefault
            enablePan={false}
            target={[0, 1.7, 0]}
          />
        </Canvas>
      </main>
    </div>
  );
}
