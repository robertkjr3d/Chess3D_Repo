import { useState } from "react";
import { Canvas } from "@react-three/fiber";
import { OrbitControls, useGLTF } from "@react-three/drei";
import "./App.css";

function Square({ position, color }) {
  return (
    <mesh position={position}>
      <boxGeometry args={[1, 0.15, 1]} />
      <meshStandardMaterial color={color} />
    </mesh>
  );
}

function BoardLevel({ y, flip = false }) {
  const squares = [];
  for (let x = 0; x < 8; x++) {
      for (let z = 0; z < 4; z++) {
      // flip z-axis so logical z=0 is the top-most board visually
      const zIndex = 3 - z;
      const isWhite = ((x + zIndex + (flip ? 1 : 0)) % 2) !== 0;
      squares.push(
        <Square
          key={`${y}-${x}-${z}`}
          position={[x - 3.5, y, zIndex - 3.5]}
          color={isWhite ? "#f0d9b5" : "#b58863"}
        />
      );
    }
  }
  return <group>{squares}</group>;
}

function QuadLevelBoard() {
  return (
    <group>
      <BoardLevel y={0} flip={true} />
      <BoardLevel y={3.725} flip={false} />
      <BoardLevel y={6.6} flip={true} />
      <BoardLevel y={8.75} flip={false} />
    </group>
  );
}

function Pieces() {
  const levels = [0, 3.725, 6.6, 8.75];
  const pieces = [];

  // Load GLB models from public/models
  const kingGltf = useGLTF('/models/king2.glb');
  const pawnGltf = useGLTF('/models/pawn2.glb');
  const knightGltf = useGLTF('/models/knight_-_staunton_full_size_chess_set.glb');
  const bishopGltf = useGLTF('/models/bishop_-_staunton_full_size_chess_set.glb');
  const rookGltf = useGLTF('/models/rook_-_staunton_full_size_chess_set.glb');
  const queenGltf = useGLTF('/models/queen_-_staunton_full_size_chess_set.glb');

  // Per-piece scale constants (tweak these if models look too big/small)
  const scaleMap = {
    pawn: 0.014,
    knight: 0.014,
    bishop: 0.014,
    rook: 0.014,
    queen: 0.014,
    king: 0.014,
  };

  function cloneAndColor(gltf, color) {
    const obj = gltf.scene.clone(true);
    obj.traverse((n) => {
      if (n.isMesh) {
        if (n.material) {
          n.material = n.material.clone();
          try { n.material.color.set(color); } catch (e) {}
          n.castShadow = true;
          n.receiveShadow = true;
        }
      }
    });
    return obj;
  }

  levels.forEach((y, li) => {
    // Pawns: black pawns at x=1 across all levels and z columns; white pawns mirrored at x=6.
    for (let z = 0; z < 4; z++) {
      const blackX = 1 - 3.5;
      const whiteX = 6 - 3.5;
      const wy = y + 0.11; // vertical offset
      const wz = (3 - z) - 3.5; // flip z so z=0 is top

      pieces.push(
        <primitive
          key={`b-pawn-${li}-${z}`}
          object={cloneAndColor(pawnGltf, '#222222')}
          position={[blackX, wy, wz]}
          scale={scaleMap.pawn}
        />
      );

      pieces.push(
        <primitive
          key={`w-pawn-${li}-${z}`}
          object={cloneAndColor(pawnGltf, '#ffffff')}
          position={[whiteX, wy, wz]}
          scale={scaleMap.pawn}
          rotation={[0, Math.PI, 0]}
        />
      );
    }

    // Specific black pieces placements (x=0) and mirrored white pieces (x=7)
    const placements = [
      { x: 0, y: 0, z: 0, t: 'R' },
      { x: 0, y: 1, z: 0, t: 'K' },
      { x: 0, y: 2, z: 0, t: 'B' },
      { x: 0, y: 3, z: 0, t: 'R' },
      { x: 0, y: 0, z: 1, t: 'B' },
      { x: 0, y: 1, z: 1, t: 'Q' },
      { x: 0, y: 2, z: 1, t: 'K' },
      { x: 0, y: 3, z: 1, t: 'N' },
      { x: 0, y: 0, z: 2, t: 'N' },
      { x: 0, y: 1, z: 2, t: 'K' },
      { x: 0, y: 2, z: 2, t: 'Q' },
      { x: 0, y: 3, z: 2, t: 'B' },
      { x: 0, y: 0, z: 3, t: 'R' },
      { x: 0, y: 1, z: 3, t: 'B' },
      { x: 0, y: 2, z: 3, t: 'N' },
      { x: 0, y: 3, z: 3, t: 'R' },
    ];

    placements.forEach((p, idx) => {
      if ((3 - p.y) === li) {
        const bx = p.x - 3.5;
        const by = y + 0.11; // vertical offset
        const bz = (3 - p.z) - 3.5; // flip z so logical z maps to visual

        const modelMap = {
          R: rookGltf,
          N: knightGltf,
          B: bishopGltf,
          K: kingGltf,
          Q: queenGltf,
        };

        const gltf = modelMap[p.t] || pawnGltf;
        const pieceNameMap = { N: 'knight', B: 'bishop', K: 'king', Q: 'queen' };
        const s = scaleMap[pieceNameMap[p.t] || 'pawn'];
        pieces.push(
          <primitive
            key={`b-${p.t.toLowerCase()}-${li}-${idx}`}
            object={cloneAndColor(gltf, '#222222')}
            position={[bx, by, bz]}
            scale={s}
          />
        );

        const mx = 7 - p.x - 3.5;
        pieces.push(
          <primitive
            key={`w-${p.t.toLowerCase()}-${li}-${idx}`}
            object={cloneAndColor(gltf, '#ffffff')}
            position={[mx, by, bz]}
            scale={s}
            rotation={[0, Math.PI, 0]}
          />
        );
      }
    });
  });

  return <group>{pieces}</group>;
}

export default function App() {
  const [aiSide, setAiSide] = useState(null);

  return (
    <div className="layout">
      <aside className="sidebar">
        <h2 className="title">Quadlevel 3D Chess</h2>
        <div className="menu">
          <button className="menu-button" onClick={() => setAiSide('white')}>
            Play AI White
          </button>
          <button className="menu-button" onClick={() => setAiSide('black')}>
            Play AI Black
          </button>
        </div>
        {aiSide && <div className="status">AI playing: {aiSide}</div>}
      </aside>
      <main className="main">
        <Canvas className="canvas" camera={{ position: [6, 5, -8], fov: 32 }}>
          <ambientLight intensity={0.6} />
          <directionalLight position={[5, 12, 5]} intensity={0.9} />
          <group scale={0.470}>
            <QuadLevelBoard />
            <Pieces />
          </group>
          <OrbitControls
            makeDefault
            enablePan={false}
            target={[0, 1.7, 0]}
          />
        </Canvas>
      </main>
    </div>
  );
}
