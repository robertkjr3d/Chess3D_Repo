import { useState, useRef, useEffect, useMemo, useCallback } from "react";
import * as THREE from 'three';
//import { Canvas, useThree, useFrame } from "@react-three/fiber";
import { Canvas, useThree } from "@react-three/fiber";
import { OrbitControls, useGLTF } from "@react-three/drei";
import "./App.css";

const GLOBAL_PIECE_SCALE = {
  pawn: 0.013,
  knight: 0.013,
  bishop: 0.013,
  rook: 0.013,
  queen: 0.013,
  king: 0.013,
};
const GHOST_SCALE_FACTOR = 1.0;
// Per-level multiplier applied to the dragged ghost.
// Note: logical level `z` is ordered with z=0 at the TOP board and z=3 at the BOTTOM board.
// Index mapping: DRAG_LEVEL_SCALE[0] -> top board (z0), ... DRAG_LEVEL_SCALE[3] -> bottom board (z3).
// Tweak these values to make ghosts smaller/larger per-board level.
//const DRAG_LEVEL_SCALE = [1.0, 0.8, 0.7, 0.6];
const DRAG_LEVEL_SCALE = [0.6, 0.7, 0.8, 1.0];

// Tuning constants for move hit detection
// Adjust these to make clicking/drags more or less permissive.
// - MOVE_PIXEL_THRESH: pixel distance from pointer to indicator to accept click
// - MOVE_WORLD_THRESH: fallback world-space distance (units) when screen-space unavailable
// - MOVE_HIT_RADIUS: invisible hit-sphere radius (world units) around indicator
const MOVE_PIXEL_THRESH = 90; // pixels
const MOVE_WORLD_THRESH = 1.6; // world units
const MOVE_HIT_RADIUS = 0.5; // world units

// Y positions for each logical level `z` (index 0 = TOP board, index 3 = BOTTOM board)
const LEVEL_Y = [8.75, 6.6, 3.725, 0];

// Known king-side blocking patterns (notation: "sx,sy,sz->kx,ky,kz" => blocking square)
// These are small hard-coded exceptions for QuadLevel geometry where an orthogonal piece
// blocks a castling path even though straight-line checks might not catch it.
const KING_BLOCK_MAP = {
  '0,2,2->0,3,2': '0,2,3',
  '0,2,2->0,2,3': '0,3,2',
  '0,1,1->0,1,0': '0,0,1',
  '0,1,1->0,0,1': '0,1,0',
};

// Optional map to provide explicit rook-from coordinates for tricky castling cases.
// Keys use the same "sx,sy,sz->kx,ky,kz" format as KING_BLOCK_MAP.
const ROOK_FROM_MAP = {};

function lookupKingBlock(sx, sy, sz, kx, ky, kz, effectiveMap, color) {
  try {
    const kMapKey = `${sx},${sy},${sz}->${kx},${ky},${kz}`;
    let mapped = (effectiveMap && effectiveMap[kMapKey]) || KING_BLOCK_MAP[kMapKey];
    const mirror = (s) => {
      const [ax, ay, az] = s.split(',').map(Number);
      return `${7 - ax},${ay},${az}`;
    };
    if (!mapped && color === 'white') {
      const mirroredKey = `${mirror(`${sx},${sy},${sz}`)}->${mirror(`${kx},${ky},${kz}`)}`;
      const mappedMirrored = (effectiveMap && effectiveMap[mirroredKey]) || KING_BLOCK_MAP[mirroredKey];
      if (mappedMirrored) mapped = mirror(mappedMirrored);
    }
    return mapped || null;
  } catch (e) { return null; }
}

// Diagnostic component: logs Canvas mount/unmount events for a given key
function CanvasLogger({ canvasKey }) {
  useEffect(() => {
    try { console.debug('Canvas mounted with key', canvasKey); } catch (e) {}
    return () => { try { console.debug('Canvas unmounted with key', canvasKey); } catch (e) {} };
  }, [canvasKey]);
  return null;
}

function isBlockedByKingBlockMap(sx, sy, sz, kx, ky, kz, occupiedMap, color) {
  try {
    const kMapKey = `${sx},${sy},${sz}->${kx},${ky},${kz}`;
    let mapped = KING_BLOCK_MAP[kMapKey];
    if (!mapped && color === 'white') {
      const mirror = (s) => {
        const [ax, ay, az] = s.split(',').map(Number);
        return `${7 - ax},${ay},${az}`;
      };
      const mirroredKey = `${mirror(`${sx},${sy},${sz}`)}->${mirror(`${kx},${ky},${kz}`)}`;
      const mappedMirrored = KING_BLOCK_MAP[mirroredKey];
      if (mappedMirrored) mapped = mirror(mappedMirrored);
    }
    if (mapped && occupiedMap && occupiedMap.has(mapped)) return true;
  } catch (e) {}
  return false;
}

// Helper utilities for move/check logic
//function keyOf(x,y,z){return `${x},${y},${z}`;}
function inBounds(x,y,z){return x>=0 && x<=7 && y>=0 && y<=3 && z>=0 && z<=3;}

function isSquareAttacked(pieces, tx, ty, tz, byColor) {
  // pieces: array of {x,y,z,t,color}
  const enemy = byColor;
  const dir = enemy === 'white' ? -1 : 1; // white pawns move -1 in x
  for (const p of pieces) {
    if (p.color !== enemy) continue;
    if (p.t === 'p') {
      const oneX = p.x + dir;
      const candidates = [[p.y+1,p.z],[p.y-1,p.z],[p.y,p.z+1],[p.y,p.z-1]];
      for (const [cy,cz] of candidates) {
        if (oneX === tx && cy === ty && cz === tz) return true;
      }
    }
  }
  // knights
  const knightOffsets = [[2,1,0],[1,2,0],[2,0,1],[1,0,2],[-2,1,0],[-1,2,0],[-2,0,1],[-1,0,2],[2,-1,0],[1,-2,0],[2,0,-1],[1,0,-2],[-2,-1,0],[-1,-2,0],[-2,0,-1],[-1,0,-2]];
  for (const p of pieces) {
    if (p.color !== enemy) continue;
    if (p.t === 'N') {
      for (const [dx,dy,dz] of knightOffsets) {
        if (p.x+dx === tx && p.y+dy === ty && p.z+dz === tz) return true;
      }
    }
  }
  // king adjacency
  const kingOffsets = [[1,0,0],[-1,0,0],[0,1,0],[0,-1,0],[0,0,1],[0,0,-1],[1,1,0],[1,-1,0],[-1,1,0],[-1,-1,0],[1,0,1],[1,0,-1],[-1,0,1],[-1,0,-1]];
  for (const p of pieces) {
    if (p.color !== enemy) continue;
    if (p.t === 'K') {
      for (const [dx,dy,dz] of kingOffsets) {
        if (p.x+dx === tx && p.y+dy === ty && p.z+dz === tz) return true;
      }
    }
  }

  // sliding pieces: scan from target outwards along directions and see first piece
  const rookDirs = [[1,0,0],[-1,0,0],[0,1,0],[0,-1,0],[0,0,1],[0,0,-1]];
  const bishopDirs = [[1,1,0],[1,-1,0],[-1,1,0],[-1,-1,0],[1,0,1],[1,0,-1],[-1,0,1],[-1,0,-1]];
  const allDirs = rookDirs.concat(bishopDirs);
  for (const [dx,dy,dz] of allDirs) {
    for (let step=1;;step++){
      const nx = tx + dx*step;
      const ny = ty + dy*step;
      const nz = tz + dz*step;
      if (!inBounds(nx,ny,nz)) break;
      const occ = pieces.find(pp => pp.x===nx && pp.y===ny && pp.z===nz);
      if (!occ) continue;
      if (occ.color !== enemy) break; // blocked by non-attacker
      // occ is attacker; check type compatibility
      const isRookLike = rookDirs.some(d => d[0]===dx && d[1]===dy && d[2]===dz);
      const isBishopLike = bishopDirs.some(d => d[0]===dx && d[1]===dy && d[2]===dz);
      if (occ.t === 'Q') return true;
      if (occ.t === 'R' && isRookLike) return true;
      if (occ.t === 'B' && isBishopLike) return true;
      break;
    }
  }
  return false;
}

function simulateMove(pieces, moverId, target) {
  // return new pieces array after moving moverId to target and removing captured enemy on that square
  const mover = pieces.find(p => p.id === moverId);
  if (!mover) return pieces.slice();
  const movingColor = mover.color;
  // handle en-passant if target includes capturedId
  let filtered = pieces.slice();
  if (target) {
    // explicit capturedId (used by some special moves)
    if (target.capturedId) {
      filtered = pieces.filter(pp => pp.id !== target.capturedId);
    } else if (target.enPassant) {
      // en-passant: captured pawn is on mover's original file (mover.x) and at landing y/z
      const moverOrig = mover;
      const captured = pieces.find(pp => pp.color !== movingColor && pp.t === 'p' && pp.x === moverOrig.x && pp.y === target.y && pp.z === target.z);
      if (captured) filtered = pieces.filter(pp => pp.id !== captured.id);
    } else {
      // normal capture: remove any enemy piece currently on the target square
      filtered = pieces.filter(pp => !(pp.x === target.x && pp.y === target.y && pp.z === target.z && pp.color !== movingColor));
    }
  }
  const next = filtered.map(pp => {
    if (pp.id === moverId) return { ...pp, x: target.x, y: target.y, z: target.z, hasMoved: true };
    // handle castling rook move when target.castle provided
    if (target && target.castle && pp.id === target.castle.rookId) {
      const rt = target.castle.rookTo;
      return { ...pp, x: rt.x, y: rt.y, z: rt.z, hasMoved: true };
    }
    return pp;
  });
  return next;
}

function isAnyKingInCheck(pieces, color) {
  // find all kings for color; return true if any king is attacked by opponent
  const kings = pieces.filter(p => p.t === 'K' && p.color === color);
  const enemy = color === 'white' ? 'black' : 'white';
  for (const k of kings) {
    if (isSquareAttacked(pieces, k.x, k.y, k.z, enemy)) return true;
  }
  return false;
}

function attackersOfSquare(pieces, tx, ty, tz) {
    const res = [];
    for (const p of pieces) {
      if (attacksSquareByPiece(p, tx, ty, tz, pieces)) res.push(p);
    }
    return res;
  }

// Static Exchange Evaluation (SEE) for a target square. Returns net material gain from the
// perspective of `sideToMove` after the sequence of optimal captures on the square.
function staticExchangeEval(pieces, tx, ty, tz, sideToMove) {
  const vals = { p: 1, N: 3, B: 3, R: 5, Q: 9, K: 10000 };
  // shallow copy of pieces for simulation
  let board = pieces.map(p => ({ ...p }));
  // helper to get piece value
  const pieceValue = (t) => vals[t] || 0;
  // initial captured piece value
  const initial = board.find(p => p.x === tx && p.y === ty && p.z === tz);
  const g = [];
  g[0] = initial ? pieceValue(initial.t) : 0;
  let side = sideToMove;
  let depth = 0;
  while (true) {
    // find attackers of square on current board for `side`
    const attackers = attackersOfSquare(board, tx, ty, tz).filter(a => a.color === side);
    if (!attackers || attackers.length === 0) break;
    // choose least valuable attacker
    let least = attackers.reduce((a, b) => (pieceValue(a.t) <= pieceValue(b.t) ? a : b));
    g[depth + 1] = pieceValue(least.t) - g[depth];
    // remove the least attacker from board
    board = board.filter(p => p.id !== least.id);
    // remove any opposing piece on the square (it was captured)
    board = board.filter(p => !(p.x === tx && p.y === ty && p.z === tz && p.color !== least.color));
    // place the attacker on the square as the new occupant
    board.push({ id: -1 - depth, x: tx, y: ty, z: tz, t: least.t, color: least.color });
    // next side
    side = side === 'white' ? 'black' : 'white';
    depth++;
    if (depth > 32) break; // safety
  }
  // back propagate best results
  for (let i = g.length - 2; i >= 0; i--) {
    g[i] = Math.max(-g[i + 1], g[i]);
  }
  return g[0];
}

function canPieceMoveTo(piece, tx, ty, tz, pieces) {
  // raw move perm (igno king in check)
  if (!inBounds(tx,ty,tz)) return false;
  // cannot move onto friendly-occupied square
  const occ = pieces.find(pp => pp.x===tx && pp.y===ty && pp.z===tz);
  if (occ && occ.color === piece.color) return false;
  // pawn forward moves (one or two) are not captures and handled specially
  if (piece.t === 'p') {
    // captures
    if (attacksSquareByPiece(piece, tx, ty, tz, pieces)) return true;
    const dir = piece.color === 'white' ? -1 : 1;
    // one-step forward
    if (tx === piece.x + dir && ty === piece.y && tz === piece.z && !occ) return true;
    // two-step from start
    const startX = piece.color === 'white' ? 6 : 1;
    if (piece.x === startX && tx === piece.x + dir*2 && ty === piece.y && tz === piece.z) {
      const mid = pieces.find(pp => pp.x === piece.x + dir && pp.y === piece.y && pp.z === piece.z);
      if (!mid && !occ) return true;
    }
    return false;
  }
  // other pieces: reuse attack test (covers knights, kings, sliding pieces)
  return attacksSquareByPiece(piece, tx, ty, tz, pieces);
}

function hasAnyLegalMove(pieces, color) {
  for (const p of pieces) {
    if (p.color !== color) continue;
    // brute force all areas for possible moves
    for (let x = 0; x < 8; x++) {
      for (let y = 0; y < 4; y++) {
        for (let z = 0; z < 4; z++) {
          if (!canPieceMoveTo(p, x, y, z, pieces)) continue;
          const next = simulateMove(pieces, p.id, { x, y, z });
          if (!isAnyKingInCheck(next, p.color)) return true;
        }
      }
    }
  }
  return false;
}

function canAnyPieceCaptureAttackers(pieces, attackerList) {
  if (!attackerList || attackerList.length === 0) return false;
  const attackerCoords = attackerList.map(a => ({ x: a.x, y: a.y, z: a.z, id: a.id }));
  for (const p of pieces) {
    for (const a of attackerCoords) {
      if (!canPieceMoveTo(p, a.x, a.y, a.z, pieces)) continue;
      const next = simulateMove(pieces, p.id, { x: a.x, y: a.y, z: a.z });
      // ensure attacker removed and move doesn't leave mover in check
      const stillHasAttacker = next.find(pp => pp.id === a.id);
      if (stillHasAttacker) continue;
      if (!isAnyKingInCheck(next, p.color)) return true;
    }
  }
  return false;
}

function cloneAndColor(gltf, color) {
  const obj = gltf.scene.clone(true);
  // normalize any embedded scale so external scale props control final size
  try { obj.scale.set(1,1,1); } catch (err) {}
  // compute bounding box and normalize to unit height so different model units match
  try {
    const box = new THREE.Box3().setFromObject(obj);
    const size = new THREE.Vector3();
    box.getSize(size);
    const h = size.y || 0;
    if (h > 1e-6) {
      const f = 1.0 / h;
      try { obj.scale.set(f, f, f); } catch (err) {}
      obj.userData._normalizedHeight = h;
    }
  } catch (err) {}

  obj.traverse((n) => {
    if (n.isMesh) {
      if (n.material) {
        n.material = n.material.clone();
        try { n.material.color.set(color); } catch (e) {}
        n.castShadow = true;
        n.receiveShadow = true;
      }
    }
  });
  return obj;
}

// Per-piece attack test: does `piece` attack target (tx,ty,tz) considering blocking in `pieces`?
function attacksSquareByPiece(piece, tx, ty, tz, pieces, lastMove) {
  if (!piece) return false;
  // dx/dy/dz were unused here and removed to satisfy lint
  if (piece.t === 'p') {
    const dir = piece.color === 'white' ? -1 : 1;
    const oneX = piece.x + dir;
    if (oneX !== tx) return false;
    if ((piece.y+1 === ty && piece.z === tz) || (piece.y-1 === ty && piece.z === tz) || (piece.y === ty && piece.z+1 === tz) || (piece.y === ty && piece.z-1 === tz)) return true;
    return false;
  }
  if (piece.t === 'N') {
    const moves = [[2,1,0],[1,2,0],[2,0,1],[1,0,2]];
    for (const [ax,ay,az] of moves) {
      const xs = ax === 0 ? [0] : [-ax, ax];
      const ys = ay === 0 ? [0] : [-ay, ay];
      const zs = az === 0 ? [0] : [-az, az];
      for (const x of xs) for (const y of ys) for (const z of zs) {
        if (!(z === 0 || y === 0)) continue;
        if (piece.x + x === tx && piece.y + y === ty && piece.z + z === tz) return true;
      }
    }
    return false;
  }
  if (piece.t === 'K') {
    const dirs = [[1,0,0],[-1,0,0],[0,1,0],[0,-1,0],[0,0,1],[0,0,-1],[1,1,0],[1,-1,0],[-1,1,0],[-1,-1,0],[1,0,1],[1,0,-1],[-1,0,1],[-1,0,-1]];
    for (const [rx,ry,rz] of dirs) {
      if (piece.x + rx === tx && piece.y + ry === ty && piece.z + rz === tz) return true;
    }
    return false;
  }
  // sliding pieces R, B, Q
  const rookDirs = [[1,0,0],[-1,0,0],[0,1,0],[0,-1,0],[0,0,1],[0,0,-1]];
  const bishopDirs = [[1,1,0],[1,-1,0],[-1,1,0],[-1,-1,0],[1,0,1],[1,0,-1],[-1,0,1],[-1,0,-1]];
  const allDirs = rookDirs.concat(bishopDirs);
  for (const [dxu,dyu,dzu] of allDirs) {
    // check along this dir from piece until out of bounds
    for (let step=1;;step++){
      const nx = piece.x + dxu*step;
      const ny = piece.y + dyu*step;
      const nz = piece.z + dzu*step;
      if (!inBounds(nx,ny,nz)) break;
      if (nx === tx && ny === ty && nz === tz) {
        // ensure piece type supports this dir
        if (piece.t === 'Q') return true;
        if (piece.t === 'R' && rookDirs.some(d => d[0]===dxu && d[1]===dyu && d[2]===dzu)) return true;
        if (piece.t === 'B' && bishopDirs.some(d => d[0]===dxu && d[1]===dyu && d[2]===dzu)) return true;
        return false;
      }
      // if blocked before reaching target, stop
      const occ = pieces.find(pp => pp.x === nx && pp.y === ny && pp.z === nz);
      if (occ) break;
    }
  }
  return false;
}
    function Square({ position, color }) {
      return (
        <mesh position={position}>
          <boxGeometry args={[1, 0.15, 1]} />
          <meshStandardMaterial color={color} />
        </mesh>
      );
    }

    function BoardLevel({ y, flip = false, flipBoard = false }) {
      const squares = [];
      for (let x = 0; x < 8; x++) {
        for (let row = 0; row < 4; row++) {
          // within-board rows use logical y; flip so logical y=0 maps to visual top within board
          const yIndex = 3 - row;
          const baseWhite = ((x + yIndex + (flip ? 1 : 0)) % 2) !== 0;
          const isWhite = flipBoard ? !baseWhite : baseWhite;
          squares.push(
            <Square
              key={`${y}-${x}-${row}`}
              // world coordinates: X, world Y (level), world Z (in-board row)
              position={[x - 3.5, y, yIndex - 3.5]}
              color={isWhite ? "#f0d9b5" : "#b58863"}
            />
          );
        }
      }
      return <group>{squares}</group>;
    }

    function QuadLevelBoard({ flipBoard = false }) {
      // render from bottom -> top for correct visual stacking
      const bottomToTop = LEVEL_Y.slice().reverse();
      return (
        <group>
          {bottomToTop.map((y, i) => <BoardLevel key={`lvl-${i}`} y={y} flip={i % 2 === 0} flipBoard={flipBoard} />)}
        </group>
      );
    }

    function Pieces({ piecesState, setPiecesState, selectedPieceId, setSelectedPieceId, isDragging, dragPoint, setIsDragging, setDragPoint, dragPointWorld, setDragPointWorld, setPointerActive, controlsRef, pointerDownRef, pointerStartRef, pointerStartScreenRef, pointerLastScreenRef, pointerDepthRef, pointerDownPieceRef, pointerDownWasSelectedRef, kingGltf, pawnGltf, knightGltf, bishopGltf, rookGltf, queenGltf, clones, pendingDrop, setPendingDrop, groupRef, setDragHeight, sceneScale, currentTurn, setCurrentTurn, lastMove, setLastMove, setMoveHistory, moveHistory, showCastlePrompt, gameOver, generateMoveNotation, moveLockRef, aiSide, pushStateSnapshot }) {
      const levels = LEVEL_Y;
      const pieces = [];

      // Per-piece scale constants (tweak these if models look too big/small)
      const scaleMap = GLOBAL_PIECE_SCALE;

      // piecesState is an array of piece objects with {id,x,y,z,t,color}
      const allPieces = piecesState;

      // occupancy set keyed by logical coords (unused currently)

      // helper to convert logical coords to world positions
      function worldPosFromLogical(lx, ly, lz) {
        // When it's Black's turn we mirror the X axis so the board appears reversed
        // do not auto-flip board view when an AI player is running
        const effectiveLX = (aiSide ? lx : ((currentTurn === 'black') ? (7 - lx) : lx));
        const wx = effectiveLX - 3.5;
        const wy = levels[lz] + 0.11;
        const wz = (3 - ly) - 3.5;
        return [wx, wy, wz];
      }

      // compute legal moves for a selected white piece (pawns + knights)
      const legalMoves = useMemo(() => {
        const occupiedMap = new Map(allPieces.map((p) => [`${p.x},${p.y},${p.z}`, p.color]));
        let moves = [];
        if (selectedPieceId == null) return moves;
        const sel = allPieces.find((pp) => pp.id === selectedPieceId);
        if (!sel || sel.color !== currentTurn) return moves;
        const { x: sx, y: sy, z: sz, t: st } = sel;
        const friendly = sel.color;
        const enemy = friendly === 'white' ? 'black' : 'white';
        if (st === 'p') {
          // pawn forward depends on color: white moves -1 in x (toward 0), black moves +1
          const dir = friendly === 'white' ? -1 : 1;
          const oneX = sx + dir;
          if (oneX >= 0 && oneX <= 7) {
            const keyOne = `${oneX},${sy},${sz}`;
            if (!occupiedMap.has(keyOne)) {
              moves.push({ x: oneX, y: sy, z: sz });
              // two-step from starting rank
              const startX = friendly === 'white' ? 6 : 1;
              const twoX = sx + dir * 2;
              const keyTwo = `${twoX},${sy},${sz}`;
              if (sx === startX && twoX >= 0 && twoX <= 7 && !occupiedMap.has(keyTwo)) {
                moves.push({ x: twoX, y: sy, z: sz });
              }
            }
            // capture diagonals: X+dir, Y+-1 same Z
            [[sy+1, sz], [sy-1, sz], [sy, sz+1], [sy, sz-1]].forEach(([cy, cz]) => {
              if (cy >= 0 && cy <= 3 && cz >= 0 && cz <= 3) {
                const k = `${oneX},${cy},${cz}`;
                if (occupiedMap.get(k) === enemy) moves.push({ x: oneX, y: cy, z: cz });
              }
            });
            // en-passant: if enemy just moved a pawn two squares and is adjacent in Y/Z and at same X
            try {
              if (lastMove && lastMove.doubleStep && lastMove.to) {
                // lastMove.to.x should equal the captor's x (enemy pawn landed adjacent in Y/Z)
                if (lastMove.to.x === sx) {
                  const ay = lastMove.to.y; const az = lastMove.to.z;
                  const manh = Math.abs(ay - sy) + Math.abs(az - sz);
                  try { console.log('en-passant check', { lastMove: lastMove.to, sx, sy, sz, oneX, ay, az, manh }); } catch (e) {}
                  if (manh === 1) {
                    // can capture en-passant landing at oneX,ay,az
                    if (oneX >= 0 && oneX <= 7) {
                      moves.push({ x: oneX, y: ay, z: az, enPassant: true, capturedId: lastMove.id });
                      try { console.log('en-passant candidate added', { moverId: sel.id, from: [sx,sy,sz], landing: [oneX, ay, az], capturedId: lastMove.id, lastMove }); } catch (e) {}
                    }
                  }
                }
              }
            } catch (err) { console.debug('en-passant check error', err); }
          }
        }
        if (st === 'N') {
          // Knight moves allowed only in X-Y (dz=0) or X-Z (dy=0) planes
          const perms = [[2, 1, 0], [1, 2, 0], [2, 0, 1], [1, 0, 2]];
          const moveSet = new Set();
          perms.forEach(([ax, ay, az]) => {
            const xs = ax === 0 ? [0] : [-ax, ax];
            const ys = ay === 0 ? [0] : [-ay, ay];
            const zs = az === 0 ? [0] : [-az, az];
            xs.forEach((dx) => ys.forEach((dy) => zs.forEach((dz) => {
              // enforce plane constraint: either dz===0 (XY move) or dy===0 (XZ move)
              if (!(dz === 0 || dy === 0)) return;
              const nx = sx + dx;
              const ny = sy + dy;
              const nz = sz + dz;
              if (nx < 0 || nx > 7 || ny < 0 || ny > 3 || nz < 0 || nz > 3) return;
              const key = `${nx},${ny},${nz}`;
              if (occupiedMap.get(key) === friendly) return;
              moveSet.add(key);
            })));
          });
          moveSet.forEach((k) => {
            const [x, y, z] = k.split(',').map(Number);
            moves.push({ x, y, z });
          });
        }
        // Rook: straight lines along x, y, or z (can move between levels vertically)
        if (st === 'R') {
          const dirs = [[1,0,0],[-1,0,0],[0,1,0],[0,-1,0],[0,0,1],[0,0,-1]];
          dirs.forEach(([dx,dy,dz]) => {
            let step = 1;
            while (true) {
              const nx = sx + dx*step;
              const ny = sy + dy*step;
              const nz = sz + dz*step;
              if (nx < 0 || nx > 7 || ny < 0 || ny > 3 || nz < 0 || nz > 3) break;
              const key = `${nx},${ny},${nz}`;
              const occ = occupiedMap.get(key);
              if (occ === friendly) break;
              moves.push({ x: nx, y: ny, z: nz });
              if (occ && occ !== friendly) break;
              step++;
            }
          });
        }

        // Bishop: diagonal moves in X-Y or X-Z planes
        if (st === 'B') {
          const dirs = [[1,1,0],[1,-1,0],[-1,1,0],[-1,-1,0],[1,0,1],[1,0,-1],[-1,0,1],[-1,0,-1]];
          dirs.forEach(([dx,dy,dz]) => {
            let step = 1;
            while (true) {
              const nx = sx + dx*step;
              const ny = sy + dy*step;
              const nz = sz + dz*step;
              if (nx < 0 || nx > 7 || ny < 0 || ny > 3 || nz < 0 || nz > 3) break;
              const key = `${nx},${ny},${nz}`;
              const occ = occupiedMap.get(key);
              if (occ === friendly) break;
              moves.push({ x: nx, y: ny, z: nz });
              if (occ && occ !== friendly) break;
              step++;
            }
          });
        }

        // Queen: combination of rook + bishop
        if (st === 'Q') {
          const dirs = [[1,0,0],[-1,0,0],[0,1,0],[0,-1,0],[0,0,1],[0,0,-1],[1,1,0],[1,-1,0],[-1,1,0],[-1,-1,0],[1,0,1],[1,0,-1],[-1,0,1],[-1,0,-1]];
          dirs.forEach(([dx,dy,dz]) => {
            let step = 1;
            while (true) {
              const nx = sx + dx*step;
              const ny = sy + dy*step;
              const nz = sz + dz*step;
              if (nx < 0 || nx > 7 || ny < 0 || ny > 3 || nz < 0 || nz > 3) break;
              const key = `${nx},${ny},${nz}`;
              const occ = occupiedMap.get(key);
              if (occ === friendly) break;
              moves.push({ x: nx, y: ny, z: nz });
              if (occ && occ !== friendly) break;
              step++;
            }
          });
        }

        // King: one-step in queen directions
        if (st === 'K') {
          const dirs = [[1,0,0],[-1,0,0],[0,1,0],[0,-1,0],[0,0,1],[0,0,-1],[1,1,0],[1,-1,0],[-1,1,0],[-1,-1,0],[1,0,1],[1,0,-1],[-1,0,1],[-1,0,-1]];
          dirs.forEach(([dx,dy,dz]) => {
            const nx = sx + dx;
            const ny = sy + dy;
            const nz = sz + dz;
            if (nx < 0 || nx > 7 || ny < 0 || ny > 3 || nz < 0 || nz > 3) return;
            const key = `${nx},${ny},${nz}`;
            if (occupiedMap.get(key) === friendly) return;
            moves.push({ x: nx, y: ny, z: nz });
          });

          // Castling (QuadLevel variant): king may castle toward a rook along X (files) or Z (levels)
          try {
            if (!sel.hasMoved) {
              const enemy = friendly === 'white' ? 'black' : 'white';
              const rooks = allPieces.filter(p => p.t === 'R' && p.color === friendly && p.x === sx);

              const queenBlockMap = {
                '0,1,1->0,3,1': '0,2,0',
                '0,1,1->0,1,3': '0,0,2',
                '0,2,2->0,0,2': '0,1,3',
                '0,2,2->0,2,0': '0,3,1',
              };
              // specific king-side blocking cases where an orthogonal piece blocks castling path
              const kingBlockMap = {
                '0,2,2->0,3,2': '0,2,3',
                '0,2,2->0,2,3': '0,3,2',              
                '0,1,1->0,1,0': '0,0,1',              
                '0,1,1->0,0,1': '0,1,0',              
              };
              // optional mapping from king-move key to the correct rook-from coords to avoid selecting wrong rook
              const rookFromMapLocal = {
                // queenBlockMap entries -> preferred rook-from positions
                '0,1,1->0,3,1': '0,0,3',
                '0,1,1->0,1,3': '0,3,0',
                '0,2,2->0,0,2': '0,3,0',
                '0,2,2->0,2,0': '0,0,3',
                // kingBlockMap entries -> preferred rook-from positions
                '0,2,2->0,3,2': '0,3,3',
                '0,2,2->0,2,3': '0,3,3',
                '0,1,1->0,1,0': '0,0,0',
                '0,1,1->0,0,1': '0,0,0',
              };
              // Merge with the global KING_BLOCK_MAP so generation and execution-time checks align
              const effectiveKingBlockMap = { ...(typeof KING_BLOCK_MAP === 'object' ? KING_BLOCK_MAP : {}), ...kingBlockMap };
              // merged rook-from map so generation can prefer explicit rook positions when provided
              const effectiveRookFromMap = { ...(typeof ROOK_FROM_MAP === 'object' ? ROOK_FROM_MAP : {}), ...rookFromMapLocal };

              const pathClearFrom = (rxx, ryy, rzz, order, targetYParam = sy, targetZParam = sz) => {
                let cx = rxx, cy = ryy, cz = rzz;
                for (const axis of order) {
                  if (axis === 'y') {
                    const targetY = targetYParam;
                    const dirY = Math.sign(targetY - cy);
                    if (dirY !== 0) {
                      for (let yy = cy + dirY; yy !== targetY; yy += dirY) {
                        if (occupiedMap.has(`${cx},${yy},${cz}`)) return false;
                      }
                    }
                    cy = targetY;
                  } else if (axis === 'z') {
                    const targetZ = targetZParam;
                    const dirZ = Math.sign(targetZ - cz);
                    if (dirZ !== 0) {
                      for (let zz = cz + dirZ; zz !== targetZ; zz += dirZ) {
                        if (occupiedMap.has(`${cx},${cy},${zz}`)) return false;
                      }
                    }
                    cz = targetZ;
                  }
                }
                return true;
              };

              // compute candidate landings (neighbors in Y/Z) once and evaluate each
              const candidateLandings = [];
              const potential = [ { x: sx, y: sy + 1, z: sz, axis: 'y' }, { x: sx, y: sy - 1, z: sz, axis: 'y' }, { x: sx, y: sy, z: sz + 1, axis: 'z' }, { x: sx, y: sy, z: sz - 1, axis: 'z' } ];
              for (const c of potential) {
                if (!inBounds(c.x, c.y, c.z)) continue;
                // only consider landings that actually move king one step in axis
                candidateLandings.push(c);
              }

              for (const landing of candidateLandings) {
                const landingKey = `${landing.x},${landing.y},${landing.z}`;
                if (occupiedMap.has(landingKey)) continue;
                if (isSquareAttacked(allPieces, sx, sy, sz, enemy)) continue;
                if (isSquareAttacked(allPieces, landing.x, landing.y, landing.z, enemy)) continue;

                // helper to compute between-exclusive coords from A to B
                const betweenExclusiveLocal = (A, B) => {
                  const res = [];
                  const dx = Math.sign(B.x - A.x);
                  const dy = Math.sign(B.y - A.y);
                  const dz = Math.sign(B.z - A.z);
                  let cx = A.x + dx, cy = A.y + dy, cz = A.z + dz;
                  while (!(cx === B.x && cy === B.y && cz === B.z)) {
                    res.push(`${cx},${cy},${cz}`);
                    cx += dx; cy += dy; cz += dz;
                    if (res.length > 20) break;
                  }
                  return res;
                };

                // ensure king path between start and landing is empty and not attacked
                let kingPathOk = true;
                try {
                  const kMapKey = `${sx},${sy},${sz}->${landing.x},${landing.y},${landing.z}`;
                  let kMapped = effectiveKingBlockMap[kMapKey];
                  if (!kMapped && friendly === 'white') {
                    const mirror = (s) => { const [ax, ay, az] = s.split(',').map(Number); return `${7 - ax},${ay},${az}`; };
                    const mirroredKey = `${mirror(`${sx},${sy},${sz}`)}->${mirror(`${landing.x},${landing.y},${landing.z}`)}`;
                    const mappedMirrored = effectiveKingBlockMap[mirroredKey];
                    if (mappedMirrored) kMapped = mirror(mappedMirrored);
                  }
                  try { console.debug('kingBlockMap check', { kMapKey, kMapped, occupied: kMapped ? occupiedMap.get(kMapped) : null }); } catch (e) {}
                  if (kMapped && occupiedMap.get(kMapped)) { kingPathOk = false; }
                } catch (e) {}

                const kingBetweenLocal = betweenExclusiveLocal({ x: sx, y: sy, z: sz }, landing);
                for (const sq of kingBetweenLocal) {
                  if (occupiedMap.has(sq)) { kingPathOk = false; break; }
                  const [kx, ky, kz] = sq.split(',').map(Number);
                  if (isSquareAttacked(allPieces, kx, ky, kz, enemy)) { kingPathOk = false; break; }
                }
                if (!kingPathOk) continue;

                // decide which rook to consider for this landing: prefer explicit mapping
                const mapKey = `${sx},${sy},${sz}->${landing.x},${landing.y},${landing.z}`;
                let mapped = effectiveRookFromMap[mapKey];
                if (!mapped && friendly === 'white') {
                  const mirror = (s) => { const [ax, ay, az] = s.split(',').map(Number); return `${7 - ax},${ay},${az}`; };
                  const mirroredKey = `${mirror(`${sx},${sy},${sz}`)}->${mirror(`${landing.x},${landing.y},${landing.z}`)}`;
                  const mappedMirrored = effectiveRookFromMap[mirroredKey];
                  if (mappedMirrored) mapped = mirror(mappedMirrored);
                }

                let rookCandidates = [];
                if (mapped) {
                  const [mrx, mry, mrz] = mapped.split(',').map(Number);
                  const found = allPieces.find(p => p.t === 'R' && p.color === friendly && p.x === mrx && p.y === mry && p.z === mrz && !p.hasMoved);
                  if (found) {
                    rookCandidates.push({ rook: found, rx: found.x, ry: found.y, rz: found.z });
                    try { console.debug('using rookFromMap mapping for castle', { mapKey, mapped }); } catch (e) {}
                  } else {
                    try { console.debug('mapped rook not present at mapped coords', { mapKey, mapped }); } catch (e) {}
                  }
                } else {
                  // fallback: find any rook in the same file (x) that could be a candidate (prefer closest in axis direction)
                  const candidates = allPieces.filter(p => p.t === 'R' && p.color === friendly && p.x === sx && !p.hasMoved);
                  if (candidates && candidates.length) {
                    // prefer rook on same axis direction as landing
                    const dir = landing.axis === 'y' ? Math.sign(landing.y - sy) : Math.sign(landing.z - sz);
                    const filtered = candidates.filter(p => {
                      if (landing.axis === 'y') return Math.sign(p.y - sy) === dir;
                      return Math.sign(p.z - sz) === dir;
                    });
                    const pick = (filtered.length ? filtered[0] : candidates[0]);
                    rookCandidates.push({ rook: pick, rx: pick.x, ry: pick.y, rz: pick.z });
                  }
                }

                // process each selected rook candidate for this landing
                for (const ri of rookCandidates) {
                  const rook = ri.rook; const rx = ri.rx; const ry = ri.ry; const rz = ri.rz;
                  // compute rookTo for king-side (king moves toward rook)
                  const rookTo = { x: sx, y: sy, z: sz };
                  const rookBetweenLocal = betweenExclusiveLocal({ x: rx, y: ry, z: rz }, rookTo);
                  let rookPathClearLocal = true;
                  for (const sq of rookBetweenLocal) { if (occupiedMap.has(sq)) { rookPathClearLocal = false; break; } }
                  if (!rookPathClearLocal) continue;
                  const okRookPathLocal = pathClearFrom(rx, ry, rz, ['y','z'], rookTo.y, rookTo.z) || pathClearFrom(rx, ry, rz, ['z','y'], rookTo.y, rookTo.z);
                  if (!okRookPathLocal) continue;
                  const neighbors = [[sx+1,sy,sz],[sx-1,sy,sz],[sx,sy+1,sz],[sx,sy-1,sz],[sx,sy,sz+1],[sx,sy,sz-1]];
                  let neighborBlocked = false;
                  for (const [nx,ny,nz] of neighbors) {
                    const k = `${nx},${ny},${nz}`;
                    if (nx < 0 || nx > 7 || ny < 0 || ny > 3 || nz < 0 || nz > 3) continue;
                    if (k === `${rx},${ry},${rz}`) continue;
                    if (k === `${landing.x},${landing.y},${landing.z}`) continue;
                    if (occupiedMap.has(k)) { neighborBlocked = true; try { console.debug('king-side neighbor blocked', { k, rook: `${rx},${ry},${rz}`, kingLanding: landing }); } catch (e) {} break; }
                  }
                  if (neighborBlocked) continue;
                  const mappedBlock = lookupKingBlock(sx, sy, sz, landing.x, landing.y, landing.z, effectiveKingBlockMap, friendly);
                  if (mappedBlock && occupiedMap && occupiedMap.has(mappedBlock)) continue;

                  const castleCand = { x: landing.x, y: landing.y, z: landing.z, castle: { type: 'king', rookId: rook.id, rookFrom: { x: rx, y: ry, z: rz }, rookTo } };
                  try {
                    if (typeof isCastleStillLegal === 'function') {
                      if (!isCastleStillLegal(sel.id, castleCand.castle, allPieces)) {
                        try { console.debug('king-side candidate rejected by isCastleStillLegal at generation', { sel: [sx,sy,sz], landing, rook: [rx,ry,rz] }); } catch (e) {}
                      } else { moves.push(castleCand); try { console.debug('king-side castle candidate added', { sx, sy, sz, landing, rook: [rx,ry,rz], rookTo }); } catch (e) {} }
                    } else { moves.push(castleCand); try { console.debug('king-side castle candidate added (no runtime check)', { sx, sy, sz, landing, rook: [rx,ry,rz], rookTo }); } catch (e) {} }
                  } catch (e) { moves.push(castleCand); }
                }

                // unified queen-side handling (both Y and Z axis cases) â€” process using any rook candidate (rx/ry/rz of first candidate)
                const ri0 = (rookCandidates && rookCandidates.length) ? rookCandidates[0] : null;
                if (!ri0) continue;
                const rx0 = ri0.rx, ry0 = ri0.ry, rz0 = ri0.rz;
                if (landing.axis === 'y' || landing.axis === 'z') {
                  const kingLanding = landing.axis === 'y' ? { x: sx, y: ry0, z: sz } : { x: sx, y: sy, z: rz0 };
                  const mapKeyQ = `${sx},${sy},${sz}->${kingLanding.x},${kingLanding.y},${kingLanding.z}`;
                  let mappedQ = queenBlockMap[mapKeyQ];
                  if (!mappedQ && friendly === 'white') {
                    const mirror = (s) => { const [ax, ay, az] = s.split(',').map(Number); return `${7 - ax},${ay},${az}`; };
                    const mirroredKey = `${mirror(`${sx},${sy},${sz}`)}->${mirror(`${kingLanding.x},${kingLanding.y},${kingLanding.z}`)}`;
                    const mappedMirrored = queenBlockMap[mirroredKey];
                    if (mappedMirrored) mappedQ = mirror(mappedMirrored);
                    try { console.debug('queenBlockMap mirrored lookup', { mirroredKey, mappedMirrored, mappedQ }); } catch (e) {}
                  }
                  try { console.debug('queenBlockMap check unified', { mapKey: mapKeyQ, mapped: mappedQ, occupied: occupiedMap.get(mappedQ) }); } catch (e) {}
                  if (mappedQ && occupiedMap.get(mappedQ)) continue;

                  const betweenExclusive = (A, B) => {
                    const res = []; const dx = Math.sign(B.x - A.x); const dy = Math.sign(B.y - A.y); const dz = Math.sign(B.z - A.z);
                    let cx = A.x + dx, cy = A.y + dy, cz = A.z + dz;
                    while (!(cx === B.x && cy === B.y && cz === B.z)) { res.push(`${cx},${cy},${cz}`); cx += dx; cy += dy; cz += dz; if (res.length > 20) break; }
                    return res;
                  };

                  const kingBetween = betweenExclusive({ x: sx, y: sy, z: sz }, kingLanding);
                  let kingPathClear = true;
                  for (const sq of kingBetween) { if (occupiedMap.has(sq)) { kingPathClear = false; break; } const [kx, ky, kz] = sq.split(',').map(Number); if (isSquareAttacked(allPieces, kx, ky, kz, enemy)) { kingPathClear = false; break; } }
                  if (!kingPathClear) continue;

                  const rookTo = landing.axis === 'y' ? { x: sx, y: sy + Math.sign(ry0 - sy), z: sz } : { x: sx, y: sy, z: sz + Math.sign(rz0 - sz) };
                  const rookBetween = betweenExclusive({ x: rx0, y: ry0, z: rz0 }, rookTo);
                  let rookPathClear = true;
                  for (const sq of rookBetween) { if (occupiedMap.has(sq)) { rookPathClear = false; break; } }
                  if (!rookPathClear) continue;
                  const okRookPath = pathClearFrom(rx0, ry0, rz0, ['y','z'], rookTo.y, rookTo.z) || pathClearFrom(rx0, ry0, rz0, ['z','y'], rookTo.y, rookTo.z);
                  if (!okRookPath) continue;
                  const mappedQBlock = lookupKingBlock(sx, sy, sz, kingLanding.x, kingLanding.y, kingLanding.z, effectiveKingBlockMap, friendly);
                  if (mappedQBlock && occupiedMap && occupiedMap.has(mappedQBlock)) continue;
                  const castleCandQ = { x: kingLanding.x, y: kingLanding.y, z: kingLanding.z, castle: { type: 'queen', rookId: ri0.rook.id, rookFrom: { x: rx0, y: ry0, z: rz0 }, rookTo } };
                  try {
                    if (typeof isCastleStillLegal === 'function') {
                      if (!isCastleStillLegal(sel.id, castleCandQ.castle, allPieces)) { try { console.debug('queen-side candidate rejected by isCastleStillLegal at generation', { sel: [sx,sy,sz], kingLanding, rook: [rx0,ry0,rz0] }); } catch (e) {} }
                      else { moves.push(castleCandQ); }
                    } else { moves.push(castleCandQ); }
                  } catch (e) { moves.push(castleCandQ); }
                }
              }
            }
          } catch (e) {}
        }
        // dedupe moves so special metadata (e.g., castle) is preserved when a standard one-step move
        // and a castling-generated move land on the same square. Merge properties in that case.
        try {
          const merged = new Map();
          const uniq = [];
          for (const m of moves) {
            const k = `${m.x},${m.y},${m.z}`;
            if (!merged.has(k)) {
              merged.set(k, m);
              uniq.push(m);
            } else {
              const existing = merged.get(k);
              if (existing && existing.castle && m.castle) {
                const mergedCopy = { ...m };
                mergedCopy.castle = existing.castle;
                Object.assign(existing, mergedCopy);
              } else {
                Object.assign(existing, m);
              }
            }
          }
          moves = uniq;
        } catch (e) {}

          // Ensure castle.type matches the actual king displacement when generated.
          // If mismatched (e.g., 'queen' recorded for a one-step king move), correct it
          // so UI prompt logic (which checks for type==='king') works reliably.
          try {
            for (const m of moves) {
              if (!m.castle) continue;
              const dy = Math.abs(m.y - sel.y);
              const dz = Math.abs(m.z - sel.z);
              const desired = (dy === 2 || dz === 2) ? 'queen' : 'king';
              if (m.castle.type !== desired) {
                try { console.debug('fixing castle.type at generation', { from: [sel.x, sel.y, sel.z], landing: [m.x, m.y, m.z], before: m.castle.type, after: desired }); } catch (e) {}
                m.castle = { ...m.castle, type: desired };
              }
            }
          } catch (e) {}

        // filter out moves that leave any of the mover's kings in check
        const legal = moves.filter((m) => {
          const next = simulateMove(allPieces, sel.id, m);
          return !isAnyKingInCheck(next, friendly);
        });
        try { if (legal.some(m => m.enPassant)) console.log('legal en-passant moves:', legal.filter(m => m.enPassant)); } catch (e) {}
        return legal;
      }, [allPieces, selectedPieceId, currentTurn, lastMove]);

      // Debug: log legal moves when selection or turn changes to diagnose capture visibility
      useEffect(() => {
        try {
          const sel = allPieces.find((pp) => pp.id === selectedPieceId);
          if (sel) {
            console.log('Selected piece:', sel, 'currentTurn:', currentTurn, 'legalMoves:', legalMoves);
          }
        } catch (e) {}
      }, [selectedPieceId, currentTurn, legalMoves, allPieces]);

      // render all pieces
      allPieces.forEach((p, idx) => {
        const world = worldPosFromLogical(p.x, p.y, p.z);
        const modelMap = {
          R: rookGltf,
          N: knightGltf,
          B: bishopGltf,
          K: kingGltf,
          Q: queenGltf,
          p: pawnGltf,
        };
        const gltf = modelMap[p.t] || pawnGltf;
        const pieceNameMap = { N: 'knight', B: 'bishop', K: 'king', Q: 'queen' };
        const s = scaleMap[pieceNameMap[p.t] || 'pawn'];

        // clickable group for white pawns and knights
        const isWhite = p.color === 'white';
        const isSelected = selectedPieceId === p.id;
        // When selected and actively dragging, render the piece at the computed local `dragPoint`
        const pos = isSelected && isDragging ? dragPoint : world;
        const visible = !(isSelected && isDragging);
        pieces.push(
          <group
            key={`${p.id}-${p.t}-${idx}`}
            position={pos}
            visible={visible}
                onPointerDown={(e) => {
              e.stopPropagation();
              try { if (pointerStartScreenRef) pointerStartScreenRef.current = { x: e.clientX, y: e.clientY }; } catch {}
              // toggle selection when clicking same piece
                  if (gameOver) return;
                  // ignore input while a move is being applied
                  if (moveLockRef.current) return;
                  if (p.color === currentTurn) {
                // record which piece was pressed and whether it was already selected
                try { pointerDownPieceRef.current = p.id; pointerDownWasSelectedRef.current = (selectedPieceId === p.id); } catch {}
                if (selectedPieceId === p.id) {
                  // pressed the already-selected piece; selection toggle handled on pointer up
                } else {
                  // select the new piece immediately so dragging can start
                  setSelectedPieceId(p.id);
                }
                // record pointer-down start and initial drag height; don't start dragging yet
                pointerDownRef.current = true;
                pointerStartRef.current = e.point || null;
                // store clip-space depth (NDC z) for later unprojection if camera available
                try {
                  const cam = e.camera || (controlsRef && controlsRef.current && controlsRef.current.object);
                  if (cam && pointerDepthRef) {
                    const vv = new THREE.Vector3(world[0], world[1], world[2]);
                    vv.project(cam);
                    pointerDepthRef.current = vv.z;
                  }
                } catch (err) {}
                // convert initial world pos into group's local coords so ghost appears at same place
                if (groupRef.current) {
                  try {
                    const lv = new THREE.Vector3(world[0], world[1], world[2]);
                    groupRef.current.worldToLocal(lv);
                    setDragPoint([lv.x, lv.y, lv.z]);
                  } catch (err) {
                    setDragPoint(world);
                  }
                } else {
                  setDragPoint([world[0] / sceneScale, world[1], world[2] / sceneScale]);
                }
                setDragHeight(world[1]);
                    try { if (setDragPointWorld) setDragPointWorld([e.point.x, e.point.y, e.point.z]); } catch {}
                    try { if (setPointerActive) setPointerActive(true); } catch {}
                // immediately disable OrbitControls so the board doesn't move while attempting drag
                try { if (controlsRef.current) controlsRef.current.enabled = false; } catch {}
              } else {
                // if user clicked an enemy piece while a piece is selected, treat as click-to-capture
                try {
                  if (selectedPieceId != null) {
                    const lx = p.x; const ly = p.y; const lz = p.z;
                    const mv = legalMoves.find(mv => mv.x === lx && mv.y === ly && mv.z === lz);
                    if (mv) {
                      e.stopPropagation();
                      try { if (controlsRef.current) controlsRef.current.enabled = false; } catch {}
                      try { moveTo(mv); } catch (err) {}
                      // consumed click
                      return;
                    }
                  }
                } catch (err) {}
                setSelectedPieceId(null);
              }
            }}
          >
            <primitive
              object={(clones && clones[`${p.t}-${isWhite ? 'white' : '#615c5c'}`]) ? clones[`${p.t}-${isWhite ? 'white' : '#615c5c'}`].clone(true) : cloneAndColor(gltf, isWhite ? '#ffffff' : '#615c5c')}
              scale={s}
              rotation={(aiSide) ? [0, 0, 0] : ((p.color === currentTurn) ? [0, Math.PI, 0] : [0, 0, 0])}
            />
          </group>
        );
      });

      // Notation helpers for 3D chess (used when recording moves)
      // Accept either 0-based coords (internal) or 1-based human coords.
      // If callers pass already 1-based values, normalize back to 0-based first.
      const squareToNotation = ({ x, y, z }) => {
        const level = z + 1; // z=0 -> 1
        const file = String.fromCharCode('a'.charCodeAt(0) + y); // y=0 -> a
        const rank = 8 - x; // x 0..7 => rank 1..8
        return `${level}${file}${rank}`;
      };

      

      // verify castling is still legal at execution time (defensive check)
      const isCastleStillLegal = (moverId, castleObj, piecesArr) => {
        try {
          if (!castleObj) return false;
          const mover = piecesArr.find(p => p.id === moverId);
          if (!mover) return false;
          if (mover.hasMoved) return false;
          const sx = mover.x, sy = mover.y, sz = mover.z;
          // kingLanding from castleObj (when king-side we stored landing as kingTo)
          const kLand = castleObj.kingTo || { x: mover.x, y: mover.y, z: mover.z };

          const rook = piecesArr.find(p => p.id === castleObj.rookId);  // this is just finding a rook.  but it needs to find the right rook...
          if (!rook) return false;
          if (rook.hasMoved) return false;
          const rx = rook.x, ry = rook.y, rz = rook.z;
          const enemy = mover.color === 'white' ? 'black' : 'white';
          const occupiedMapLocal = new Map((piecesArr || []).map(p => [`${p.x},${p.y},${p.z}`, p]));
          // check explicit king-block map
          try {
            const mapped = lookupKingBlock(sx, sy, sz, kLand.x, kLand.y, kLand.z, null, mover.color);
            if (mapped && occupiedMapLocal && occupiedMapLocal.has(mapped)) return false;
          } catch (e) {}
          // compute squares between king start and landing
          const between = (A, B) => {
            const res = [];
            const dx = Math.sign(B.x - A.x);
            const dy = Math.sign(B.y - A.y);
            const dz = Math.sign(B.z - A.z);
            let cx = A.x + dx, cy = A.y + dy, cz = A.z + dz;
            while (!(cx === B.x && cy === B.y && cz === B.z)) {
              res.push({ x: cx, y: cy, z: cz });
              cx += dx; cy += dy; cz += dz;
              if (res.length > 30) break;
            }
            return res;
          };
          const kingBetween = between({ x: sx, y: sy, z: sz }, kLand);
          // king path must be empty and not attacked
          for (const sq of kingBetween) {
            const key = `${sq.x},${sq.y},${sq.z}`;
            if (occupiedMapLocal.has(key)) return false;
            if (isSquareAttacked(piecesArr, sq.x, sq.y, sq.z, enemy)) return false;
          }
          // rookTo typically is mover original square (for king-side) or computed elsewhere; use castleObj.rookTo
          const rookTo = castleObj.rookTo || { x: sx, y: sy, z: sz };
          const rookBetween = between({ x: rx, y: ry, z: rz }, rookTo);
          for (const sq of rookBetween) {
            const key = `${sq.x},${sq.y},${sq.z}`;
            if (occupiedMapLocal.has(key)) return false;
          }
          // verify rook can reach rookTo via existing pathClearFrom logic (reuse small helper)
          const pathClearFromLocal = (rxx, ryy, rzz, order, targetYParam = sy, targetZParam = sz) => {
            let cx = rxx, cy = ryy, cz = rzz;
            for (const axis of order) {
              if (axis === 'y') {
                const targetY = targetYParam;
                const dirY = Math.sign(targetY - cy);
                if (dirY !== 0) {
                  for (let yy = cy + dirY; yy !== targetY; yy += dirY) {
                    if (occupiedMapLocal.has(`${cx},${yy},${cz}`)) return false;
                  }
                }
                cy = targetY;
              } else if (axis === 'z') {
                const targetZ = targetZParam;
                const dirZ = Math.sign(targetZ - cz);
                if (dirZ !== 0) {
                  for (let zz = cz + dirZ; zz !== targetZ; zz += dirZ) {
                    if (occupiedMapLocal.has(`${cx},${cy},${zz}`)) return false;
                  }
                }
                cz = targetZ;
              }
            }
            return true;
          };
          const okRook = pathClearFromLocal(rx, ry, rz, ['y','z'], rookTo.y, rookTo.z) || pathClearFromLocal(rx, ry, rz, ['z','y'], rookTo.y, rookTo.z);
          if (!okRook) return false;
          return true;
        } catch (e) { return false; }
      };

      // extracted move executor so modal handlers can reuse it
      const _doMove = useCallback((finalTarget) => {
        if (moveLockRef.current) return;
        moveLockRef.current = true;
        try { (typeof pushStateSnapshot !== 'undefined') && pushStateSnapshot(); } catch (e) {}
        let moverBefore = null;
        try {
        if (finalTarget && finalTarget.castle) {
          // Defensive pattern-check: ensure castle.type matches the actual king displacement
          try {
            moverBefore = piecesState.find(pp => pp.id === selectedPieceId);
            if (moverBefore) {
              const dx = Math.abs((finalTarget.x || 0) - moverBefore.x);
              const dy = Math.abs((finalTarget.y || 0) - moverBefore.y);
              const dz = Math.abs((finalTarget.z || 0) - moverBefore.z);
              const cType = finalTarget.castle.type;
              if (cType === 'queen' && !(dy === 2 || dz === 2)) {
                try { console.debug('castle type mismatch: queen but king moved one-step; stripping castle', { moverBefore, finalTarget }); } catch (e) {}
                finalTarget = { ...finalTarget, castle: null };
              }
              if (cType === 'king' && !(dy === 1 || dz === 1)) {
                try { console.debug('castle type mismatch: king but king moved multi-step; stripping castle', { moverBefore, finalTarget }); } catch (e) {}
                finalTarget = { ...finalTarget, castle: null };
              }
            }
          } catch (e) {}
          // defensive: re-check legality using latest piecesState; if illegal, strip castle metadata
          try {
            const legal = isCastleStillLegal(selectedPieceId, finalTarget.castle, piecesState || []);
            if (!legal) {
              try { console.debug('castle rejected at execution time', { selectedPieceId, finalTarget }); } catch (e) {}
              finalTarget = { ...finalTarget, castle: null };
            }
          } catch (e) { finalTarget = { ...finalTarget, castle: null }; }
        }
        if (selectedPieceId == null) return;
        moverBefore = piecesState.find(pp => pp.id === selectedPieceId);
        let notation = '';
        try { notation = generateMoveNotation(moverBefore, finalTarget, piecesState); } catch (err) { notation = ''; }
        try {
          try { console.debug('notation details', { moverBefore, target: finalTarget, targetNotation: squareToNotation(finalTarget), computedNotation: notation }); } catch (e) {}
        } catch (e) {}
        setPiecesState((prev) => {
          const mover = prev.find(pp => pp.id === selectedPieceId);
          if (!mover) return prev;
          const movingColor = mover.color;
          // if target indicates en-passant capture, remove the captured pawn by id
          let withoutCaptured;
          try {
            if (finalTarget && finalTarget.enPassant && finalTarget.capturedId) {
              withoutCaptured = prev.filter(pp => pp.id !== finalTarget.capturedId);
            } else {
              withoutCaptured = prev.filter(pp => !(pp.x === finalTarget.x && pp.y === finalTarget.y && pp.z === finalTarget.z && pp.color !== movingColor));
            }
            const next = withoutCaptured.map((pp) => {
              if (pp.id === selectedPieceId) return { ...pp, x: finalTarget.x, y: finalTarget.y, z: finalTarget.z, hasMoved: true };
              // handle castling rook movement â€” compute safe rookTo so it never lands onto the king's landing square
              if (finalTarget && finalTarget.castle && pp.id === finalTarget.castle.rookId) {
                const originalRookTo = finalTarget.castle.rookTo;
                // if rookTo equals king landing (would collide), fall back to mover's original square
                let safeRookTo = originalRookTo;
                try {
                  if (originalRookTo && finalTarget && typeof finalTarget.x === 'number' && typeof originalRookTo.x === 'number') {
                    if (originalRookTo.x === finalTarget.x && originalRookTo.y === finalTarget.y && originalRookTo.z === finalTarget.z) {
                      // fall back to mover's original position (king's origin)
                      safeRookTo = { x: mover.x, y: mover.y, z: mover.z };
                    }
                  }
                } catch (e) {}
                if (safeRookTo) return { ...pp, x: safeRookTo.x, y: safeRookTo.y, z: safeRookTo.z, hasMoved: true };
              }
              return pp;
            });
            try { console.log('moveTo:', { selectedPieceId, target: finalTarget, movingColor, beforeCount: prev.length, afterCount: next.length }); } catch (e) {}
            return next;
          } catch (e) { return prev; }
        });
        // record notation into moveHistory (use moverBefore.color for which side moved)
        try {
          const side = moverBefore ? moverBefore.color : null;
          let finalNotation = notation;
          if (!finalNotation) {
            try { finalNotation = `${squareToNotation(moverBefore || {})}-${squareToNotation(finalTarget || {})}`; } catch (e) { finalNotation = ''; }
          }
          if (finalNotation && typeof setMoveHistory === 'function') {
            try { console.debug('recording notation', { notation: finalNotation, side }); } catch (e) {}
            setMoveHistory(prev => {
              const copy = prev ? prev.slice() : [];
              if (side === 'white') {
                const last = copy.length ? copy[copy.length - 1] : null;
                if (last && last.white === finalNotation) return copy;
                copy.push({ white: finalNotation, black: null });
              } else if (side === 'black') {
                if (copy.length === 0) copy.push({ white: null, black: finalNotation });
                else copy[copy.length - 1] = { ...copy[copy.length - 1], black: finalNotation };
              }
              try { console.debug('moveHistory now', copy); } catch (e) {}
              return copy;
            });
          }
        } catch (e) { console.debug('setMoveHistory error', e); }
        setSelectedPieceId(null);
        try {
          if (setCurrentTurn) setCurrentTurn((prev) => {
            const next = prev === 'white' ? 'black' : 'white';
            try { console.debug('turn toggled', prev, '->', next); } catch (e) {}
            return next;
          });
        } catch (e) {}
        } finally {
          // release move lock after move application (small delay to avoid immediate re-entrancy)
          try { setTimeout(() => { try { moveLockRef.current = false; } catch (e) {} }, 60); } catch (e) { try { moveLockRef.current = false; } catch (e) {} }
        }
        try {
          if (moverBefore && moverBefore.t === 'p') {
            const dx = Math.abs(finalTarget.x - moverBefore.x);
            if (dx === 2) {
              const lm = { id: moverBefore.id, from: { x: moverBefore.x, y: moverBefore.y, z: moverBefore.z }, to: { x: finalTarget.x, y: finalTarget.y, z: finalTarget.z }, doubleStep: true };
              try { if (setLastMove) setLastMove(lm); try { console.log('lastMove set', lm); } catch (e) {} } catch (e) {}
            } else {
              try { if (setLastMove) { setLastMove(null); try { console.log('lastMove cleared'); } catch (e) {} } } catch (e) {}
            }
          } else {
            try { if (setLastMove) { setLastMove(null); try { console.log('lastMove cleared'); } catch (e) {} } } catch (e) {}
          }
        } catch (e) {}
      }, [selectedPieceId, piecesState, setPiecesState, setSelectedPieceId, setCurrentTurn, setLastMove, setMoveHistory, generateMoveNotation, squareToNotation, pushStateSnapshot]);

      // wrapper to prompt or execute
      const moveTo = useCallback((target) => {
        if (selectedPieceId == null) return;
        if (moveLockRef.current) return;
        try {
          if (target && target.castle && target.castle.type === 'king') {
            if (typeof showCastlePrompt === 'function') {
              showCastlePrompt({ title: 'Castle?', onYes: () => _doMove(target), onNo: () => _doMove({ ...target, castle: null }) });
              return;
            }
            const ok = typeof window !== 'undefined' ? window.confirm('Castle?') : true;
            if (!ok) { setSelectedPieceId(null); return; }
          }
        } catch (e) {}
        _doMove(target);
      }, [selectedPieceId, moveLockRef, showCastlePrompt, _doMove]);

      // when App reports a pendingDrop, decide whether it's a legal landing square
      useEffect(() => {
        if (!pendingDrop) return;
        if (selectedPieceId == null) {
          setPendingDrop(null);
          return;
        }
        try {
          // convert world point to local coords
          const v = new THREE.Vector3(pendingDrop[0], pendingDrop[1], pendingDrop[2]);
          if (groupRef && groupRef.current) groupRef.current.worldToLocal(v);
          // try: pick nearest legal move by screen-space distance (more perceptually appropriate)
          let chosenMove = null;
          try {
            if (legalMoves && legalMoves.length > 0) {
              // If we have a last screen position from pointer events, prefer pixel-distance check.
              const canvas = document.querySelector('canvas');
              const cam = controlsRef && controlsRef.current && controlsRef.current.object;
              if (pointerLastScreenRef && pointerLastScreenRef.current && canvas && cam) {
                try {
                  const rect = canvas.getBoundingClientRect();
                  let bestPx = Infinity; let bestMv = null;
                  for (const mv of legalMoves) {
                    const wp = worldPosFromLogical(mv.x, mv.y, mv.z);
                    const vec = new THREE.Vector3(wp[0], wp[1], wp[2]).project(cam);
                    const sx = rect.left + (vec.x + 1) * 0.5 * rect.width;
                    const sy = rect.top + (-vec.y + 1) * 0.5 * rect.height;
                    const dx = sx - pointerLastScreenRef.current.x;
                    const dy = sy - pointerLastScreenRef.current.y;
                    const pd = Math.hypot(dx, dy);
                    if (pd < bestPx) { bestPx = pd; bestMv = mv; }
                  }
                  if (bestMv && bestPx <= MOVE_PIXEL_THRESH) chosenMove = bestMv;
                } catch (err) { console.debug('pixel-tolerance check err', err); }
              } else {
                // fallback to world-space distance (legacy)
                let best = Infinity; let bestMv = null;
                for (const mv of legalMoves) {
                  const wp = worldPosFromLogical(mv.x, mv.y, mv.z);
                  const dx = wp[0] - v.x; const dy = wp[1] - v.y; const dz = wp[2] - v.z;
                  const d = Math.hypot(dx, dy, dz);
                  if (d < best) { best = d; bestMv = mv; }
                }
                if (bestMv && best <= MOVE_WORLD_THRESH) chosenMove = bestMv;
              }
            }
          } catch (err) { console.debug('nearest-move selection error', err); }

          // fallback: nearest logical rounding (legacy behavior)
          if (!chosenMove) {
            const lx = Math.round(v.x + 3.5);
            const ly = Math.round(3 - (v.z + 3.5));
            // pick level by closest Y
            const levels = LEVEL_Y;
            let lz = 0;
            let bestDist = Infinity;
            for (let i = 0; i < levels.length; i++) {
              const d = Math.abs(v.y - (levels[i] + 0.11));
              if (d < bestDist) { bestDist = d; lz = i; }
            }
            const moveObj = legalMoves.find(mv => mv.x === lx && mv.y === ly && mv.z === lz);
            if (moveObj) chosenMove = moveObj;
          }

          if (chosenMove) {
            moveTo(chosenMove);
          } else {
            // cancel drag: clear selection and leave piecesState unchanged
            setSelectedPieceId(null);
          }
        } catch (e) {}
        setPendingDrop(null);
        // ensure dragging state cleared
        try { if (controlsRef && controlsRef.current) controlsRef.current.enabled = true; } catch {}
        try { pointerDownRef.current = false; } catch {}
        setIsDragging(false);
        setDragPointWorld(null);
        setPointerActive(false);
      }, [pendingDrop, controlsRef, groupRef, /*legalMoves*/ legalMoves, moveTo, pointerDownRef, selectedPieceId, setDragPointWorld, setIsDragging, setPendingDrop, setPointerActive, setSelectedPieceId]);

      

      const indicators = legalMoves.map((m, i) => {
        // default indicator position is landing square
        const wp = worldPosFromLogical(m.x, m.y, m.z);
        let indicatorPos = wp.slice();
        // en-passant: show indicator at the landing square (as if the pawn had moved one square)
        if (m.enPassant) {
          indicatorPos = [wp[0], wp[1] + 0.08, wp[2]];
        } else {
          // if a piece occupies the target, raise the indicator above that piece so it's visible for captures
          const occ = allPieces.find((pp) => pp.x === m.x && pp.y === m.y && pp.z === m.z);
          if (occ) {
            const pieceNameMap = { N: 'knight', B: 'bishop', K: 'king', Q: 'queen' };
            const s = GLOBAL_PIECE_SCALE[pieceNameMap[occ.t] || 'pawn'] || 0.013;
            const topOffset = s * sceneScale + 0.05;
            indicatorPos = [wp[0], wp[1] + topOffset, wp[2]];
          }
        }
        return (
          <group key={`move-ind-${i}`} position={indicatorPos}>
            <mesh key={`move-ind-hit-${i}`} onPointerUp={(e) => { e.stopPropagation(); moveTo(m); try { if (controlsRef.current) controlsRef.current.enabled = true; } catch{} }} renderOrder={998}>
              <sphereGeometry args={[MOVE_HIT_RADIUS, 8, 8]} />
              <meshBasicMaterial transparent={true} opacity={0} depthTest={false} depthWrite={false} />
            </mesh>
            <mesh key={`move-ind-vis-${i}`} onPointerUp={(e) => { e.stopPropagation(); moveTo(m); try { if (controlsRef.current) controlsRef.current.enabled = true; } catch{} }} renderOrder={999}>
              <sphereGeometry args={[0.14, 16, 16]} />
              <meshStandardMaterial color="#ff0000" depthTest={false} depthWrite={false} />
            </mesh>
          </group>
        );
      });

      return <group>{pieces.concat(indicators)}</group>;
    }

    

    function Ghost({ dragPoint, dragPointWorld, selectedPieceId, piecesState, isDragging, pointerDownRef, kingGltf, pawnGltf, knightGltf, bishopGltf, rookGltf, queenGltf, clones, currentTurn }) {
      const sel = piecesState.find((p) => p.id === selectedPieceId);
      const modelMap = {
        R: rookGltf,
        N: knightGltf,
        B: bishopGltf,
        K: kingGltf,
        Q: queenGltf,
        p: pawnGltf,
      };
      const gltf = sel ? (modelMap[sel.t] || pawnGltf) : null;
      const color = sel ? (sel.color === 'white' ? '#ffffff' : '#615c5c') : '#ffffff';

      // create a clone and make it render on top (hook always called)
      const cloned = useMemo(() => {
        if (!gltf || !sel) return null;
        try {
          const cacheKey = `${sel.t}-${sel.color === 'white' ? 'white' : '#615c5c'}`;
          const c = (clones && clones[cacheKey]) ? clones[cacheKey].clone(true) : cloneAndColor(gltf, color);
          c.traverse((n) => {
            if (n.isMesh && n.material) {
              try { n.material = n.material.clone(); } catch (err) {}
              n.material.transparent = true;
              n.material.opacity = 0.95;
              n.material.depthTest = false;
              n.material.depthWrite = false;
              n.renderOrder = 999;
            }
          });
          return c;
        } catch (err) { return null; }
      }, [gltf, color, sel, clones]);

      // show ghost only while actively dragging; don't render on simple pointer-down
      if (!dragPoint || !sel || !isDragging) return null;

      if (!cloned) return null;

      const s = GLOBAL_PIECE_SCALE[sel.t === 'N' ? 'knight' : (sel.t === 'p' ? 'pawn' : (sel.t === 'B' ? 'bishop' : (sel.t === 'R' ? 'rook' : (sel.t === 'Q' ? 'queen' : 'king'))))] || 0.013;

      // Apply per-level multiplier so lower boards can have smaller ghosts.
      const levelIndex = (typeof sel.z === 'number') ? sel.z : 3;
      const levelFactor = (DRAG_LEVEL_SCALE && DRAG_LEVEL_SCALE[levelIndex] != null) ? DRAG_LEVEL_SCALE[levelIndex] : 1.0;
      const finalScale = s * levelFactor * GHOST_SCALE_FACTOR;

      // Ghost is rendered inside the same scaled group as pieces; use the adjusted scale so it matches.
      return (
        <group raycast={() => null} renderOrder={999}>
          <primitive object={cloned} position={dragPoint} scale={[finalScale, finalScale, finalScale]} rotation={(sel.color === currentTurn) ? [0, Math.PI, 0] : [0,0,0]} />
        </group>
      );
    }

    export default function App() {
      const [currentTurn, setCurrentTurn] = useState('white');
      const [gameOver, setGameOver] = useState(false);
      const [gameWinner, setGameWinner] = useState(null);
      const [statusMessage, setStatusMessage] = useState('');
        const [lastMove, setLastMove] = useState(null); // track last move for en-passant (double-step)
      const [aiSide, setAiSide] = useState(null);
      const [selectedPieceId, setSelectedPieceId] = useState(null);
      const [moveHistory, setMoveHistory] = useState([]); // array of { white: string|null, black: string|null }
      const [canvasKey, setCanvasKey] = useState(0);
      useEffect(() => {
        try { console.debug('canvasKey changed ->', canvasKey); } catch (e) {}
      }, [canvasKey]);
      const [gameStarted, setGameStarted] = useState(false);
      const [isDragging, setIsDragging] = useState(false);
      const [dragPoint, setDragPoint] = useState([0, 0, 0]);
      const [dragHeight, setDragHeight] = useState(0);
      const [dragPointWorld, setDragPointWorld] = useState(null);
      const [castlePrompt, setCastlePrompt] = useState(null);
      
      const [pendingDrop, setPendingDrop] = useState(null);
      const [pointerActive, setPointerActive] = useState(false);
      const pointerDownRef = useRef(false);
      const pointerStartRef = useRef(null);
      const pointerDepthRef = useRef(null);
      const pointerStartScreenRef = useRef(null);
      const pointerLastScreenRef = useRef(null);
      const pointerDownPieceRef = useRef(null);
      const pointerDownWasSelectedRef = useRef(false);
      const groupRef = useRef();
      const sceneScale = 0.470;
      // load models once at App level and pass to children
      const kingGltf = useGLTF('/models/king2.glb');
      const pawnGltf = useGLTF('/models/pawn2.glb');
      const knightGltf = useGLTF('/models/knight_-_staunton_full_size_chess_set.glb');
      const bishopGltf = useGLTF('/models/bishop_-_staunton_full_size_chess_set.glb');
      const rookGltf = useGLTF('/models/rook_-_staunton_full_size_chess_set.glb');
      const queenGltf = useGLTF('/models/queen_-_staunton_full_size_chess_set.glb');

      // build a cache of normalized clones per piece type + color so ghost and piece share same object
      const clones = useMemo(() => {
        try { console.debug('recomputing clones cache'); } catch (e) {}
        const map = {};
        const modelMap = { R: rookGltf, N: knightGltf, B: bishopGltf, K: kingGltf, Q: queenGltf, p: pawnGltf };
        ['white','#615c5c'].forEach((colorHex) => {
          Object.keys(modelMap).forEach((t) => {
            try {
              const c = cloneAndColor(modelMap[t], colorHex);
              map[`${t}-${colorHex}`] = c;
            } catch (err) {}
          });
        });
        return map;
      }, [kingGltf, pawnGltf, knightGltf, bishopGltf, rookGltf, queenGltf]);

      const showCastlePrompt = (opts) => {
        // opts: { title, onYes, onNo }
        setCastlePrompt(opts);
      };
      

      // build initial pieces list (logical coords)
      function getInitialPieces() {
        const levels = [0, 1, 2, 3]; // logical levels
        const res = [];
        let id = 1;
        levels.forEach((lz) => {
          for (let row = 0; row < 4; row++) {
            res.push({ id: id++, x: 1, y: row, z: lz, t: 'p', color: 'black', hasMoved: false });
            res.push({ id: id++, x: 6, y: row, z: lz, t: 'p', color: 'white', hasMoved: false });
          }
        });

        const placements = [
          { x: 0, y: 0, z: 0, t: 'R' },
          { x: 0, y: 1, z: 0, t: 'N' },
          { x: 0, y: 2, z: 0, t: 'B' },
          { x: 0, y: 3, z: 0, t: 'R' },
          { x: 0, y: 0, z: 1, t: 'B' },
          { x: 0, y: 1, z: 1, t: 'K' },
          { x: 0, y: 2, z: 1, t: 'Q' },
          { x: 0, y: 3, z: 1, t: 'N' },
          { x: 0, y: 0, z: 2, t: 'N' },
          { x: 0, y: 1, z: 2, t: 'Q' },
          { x: 0, y: 2, z: 2, t: 'K' },
          { x: 0, y: 3, z: 2, t: 'B' },
          { x: 0, y: 0, z: 3, t: 'R' },
          { x: 0, y: 1, z: 3, t: 'B' },
          { x: 0, y: 2, z: 3, t: 'N' },
          { x: 0, y: 3, z: 3, t: 'R' },
        ];
        placements.forEach((p) => {
          res.push({ id: id++, x: p.x, y: p.y, z: p.z, t: p.t, color: 'black', hasMoved: false });
          res.push({ id: id++, x: 7 - p.x, y: p.y, z: p.z, t: p.t, color: 'white', hasMoved: false });
        });
        return res;
      }

      const [piecesState, setPiecesState] = useState(() => getInitialPieces());
      // lightweight in-memory/localStorage debug event buffer for easier log collection
      const debugEventsRef = useRef([]);
      const pushDebug = useCallback((tag, payload) => {
        try {
          const ev = { t: Date.now(), tag, payload };
          debugEventsRef.current.push(ev);
          if (debugEventsRef.current.length > 200) debugEventsRef.current.shift();
          try { localStorage.setItem('chess3d:debugEvents', JSON.stringify(debugEventsRef.current.slice(-200))); } catch (e) {}
          try { window.__chess3d_debug = debugEventsRef.current.slice(-200); } catch (e) {}
          try { console.log('pushDebug', tag, payload); } catch (e) {}
        } catch (e) {}
      }, []);
      // reset game to initial position
      const resetGame = () => {
        try {
          setPiecesState(getInitialPieces());
          setMoveHistory([]);
          setCurrentTurn('white');
          setLastMove(null);
          setAiSide(null);
          setSelectedPieceId(null);
          setGameOver(false);
          setGameWinner(null);
          setStatusMessage('');
        } catch (e) { console.debug('resetGame error', e); }
      };
      const prevPiecesRef = useRef(piecesState);
      const prevMoveHistoryRef = useRef(moveHistory);
      const statesHistoryRef = useRef([]); // stack of previous full states for take-back

      // push a shallow snapshot of the full app state for take-back
      const pushStateSnapshot = useCallback(() => {
        try {
          // use the current live state values (not prev refs) to avoid missing snapshots
          const snap = {
            piecesState: (piecesState || []).map(p => ({ ...p })),
            moveHistory: (moveHistory || []).slice(),
            currentTurn,
            lastMove,
            aiSide,
            gameStarted,
          };
          statesHistoryRef.current.push(snap);
          try { console.debug('pushed state snapshot (take-back depth)', statesHistoryRef.current.length); } catch (e) {}
          try { if (typeof pushDebug === 'function') pushDebug('pushedSnapshot', { depth: statesHistoryRef.current.length }); } catch (e) {}
        } catch (e) { console.debug('pushStateSnapshot failed', e); }
      }, [piecesState, moveHistory, currentTurn, lastMove, aiSide, gameStarted]);

      useEffect(() => { prevMoveHistoryRef.current = moveHistory; }, [moveHistory]);

      // notation helper (app-wide): convert internal coords to human-readable notation
      const squareToNotation = ({ x, y, z } = {}) => {
        const ix = (typeof x === 'number') ? x : 0;
        const iy = (typeof y === 'number') ? y : 0;
        const iz = (typeof z === 'number') ? z : 0;
        const level = iz + 1;
        const file = String.fromCharCode('a'.charCodeAt(0) + iy);
        const rank = 8 - ix;
        return `${level}${file}${rank}`;
      };

      const generateMoveNotation = (mover, target, pieces) => {
        if (!mover) return '';
        const mapCoordForNotation = (c, color) => {
          if (!c) return c;
          const ix = (typeof c.x === 'number') ? c.x : 0;
          const iy = (typeof c.y === 'number') ? c.y : 0;
          const iz = (typeof c.z === 'number') ? c.z : 0;
          return { x: ix, y: iy, z: iz };
        };
        try { try { console.debug('generateMoveNotation inputs', { mover, target, piecesCount: pieces && pieces.length }); } catch (e) {} } catch (e) {}
        const piece = mover.t;
        const letter = piece === 'p' ? '' : piece;
        const mappedTarget = mapCoordForNotation(target || {}, mover.color);
        const mappedOrigin = mapCoordForNotation(mover, mover.color);
        const targetNotation = squareToNotation(mappedTarget || {});

        // simulate the move to detect check / mate for proper notation suffix
        let checkSuffix = '';
        let simulated = null;
        try {
          simulated = simulateMove(pieces || [], mover.id, target || {});
          const opponent = mover.color === 'white' ? 'black' : 'white';
          try {
            const oppInCheck = isAnyKingInCheck(simulated, opponent);
            const oppLegal = (getAllLegalMoves(simulated, opponent) || []);
            const isMate = oppInCheck && oppLegal.length === 0;
            checkSuffix = isMate ? '++' : (oppInCheck ? '+' : '');
          } catch (e) {
            checkSuffix = '';
          }
          try { console.debug('generateMoveNotation mapped', { mappedTarget, targetNotation, mappedOrigin, simulatedMoved: simulated && simulated.find(s => s.id === mover.id) || null, checkSuffix }); } catch (e) {}
        } catch (e) { console.debug('simulateMove in notation err', e); }

        if (target && target.castle) {
          const startLevel = mover.z + 1;
          const endLevel = (target.castle && target.castle.rookTo) ? target.castle.rookTo.z + 1 : (target.z != null ? target.z + 1 : mover.z + 1);
          const o = target.castle.type === 'queen' ? 'O-O-O' : 'O-O';
          return `${startLevel}${o}${endLevel}${checkSuffix}`;
        }

        const isCapture = !!( (target && target.enPassant) || (pieces && pieces.find(p => p.x === (target && target.x) && p.y === (target && target.y) && p.z === (target && target.z) && p.color !== mover.color)) );
        if (piece === 'p') {
          if (!isCapture) return `${targetNotation}${checkSuffix}`;
          const originFile = String.fromCharCode('a'.charCodeAt(0) + (mappedOrigin.y || 0));
          let ambiguousLevel = false;
          if (pieces && pieces.length) {
            for (const p of pieces) {
              if (p.id === mover.id) continue;
              if (p.t !== 'p' || p.color !== mover.color) continue;
              if (p.y !== mover.y) continue;
              if (canPieceMoveTo(p, target.x, target.y, target.z, pieces)) { ambiguousLevel = true; break; }
            }
          }
          if (ambiguousLevel) {
            const levelPrefix = (mappedOrigin.z != null ? (mappedOrigin.z + 1) : 1);
            return `${levelPrefix}${originFile}x${targetNotation}${checkSuffix}`;
          }
          return `${originFile}x${targetNotation}${checkSuffix}`;
        }
        let ambiguous = false;
        if (letter !== '') {
          for (const p of pieces) {
            if (p.id === mover.id) continue;
            if (p.t !== mover.t) continue;
            if (p.color !== mover.color) continue;
            if (canPieceMoveTo(p, target.x, target.y, target.z, pieces)) { ambiguous = true; break; }
          }
        }
        if (!ambiguous) return `${letter}${isCapture ? 'x' : ''}${targetNotation}${checkSuffix}`;
        const origin = squareToNotation(mappedOrigin || {});
        return `${letter}(${origin})${isCapture ? 'x' : ''}${targetNotation}${checkSuffix}`;
      };

      const moveLockRef = useRef(false);

      // helper: generate all legal moves for a color
      const getAllLegalMoves = useCallback((pieces, color) => {
        const res = [];
        for (const p of pieces) {
          if (p.color !== color) continue;
          for (let x = 0; x < 8; x++) {
            for (let y = 0; y < 4; y++) {
              for (let z = 0; z < 4; z++) {
                try {
                  if (!canPieceMoveTo(p, x, y, z, pieces)) continue;
                  // For pawns, ensure diagonal captures only target enemy-occupied squares (avoid illegal diagonal moves into empty squares)
                  if (p.t === 'p') {
                    const isAttackMove = (function() {
                      try { return attacksSquareByPiece(p, x, y, z, pieces); } catch (e) { return false; }
                    })();
                    if (isAttackMove) {
                      const occ = pieces.find(pp => pp.x === x && pp.y === y && pp.z === z);
                      if (!occ || occ.color === p.color) {
                        // not a valid capture (no enemy there), skip
                        continue;
                      }
                    }
                  }
                  const next = simulateMove(pieces, p.id, { x, y, z });
                  if (!isAnyKingInCheck(next, color)) {
                    res.push({ moverId: p.id, x, y, z });
                  }
                } catch (e) {}
              }
            }
          }
        }
        return res;
      }, [simulateMove, canPieceMoveTo, isAnyKingInCheck]);
      const evaluatePosition = useCallback((pieces, color) => {
        // stronger material emphasis and center control with piece-safety penalization
        const vals = { p: 1, N: 3, B: 3, R: 5, Q: 9, K: 10000 };
        let score = 0;
        // central 8 squares explicit set (x,y,z)
        const central8 = new Set(['3,1,1','4,1,1','3,2,1','4,2,1','3,1,2','4,1,2','3,2,2','4,2,2']);
        // centrality function: prefer central ranks/files and middle levels
        const centrality = (x, y, z) => {
          let s = 0;
          if (x >= 2 && x <= 5) s += 2;
          if (y >= 1 && y <= 2) s += 2;
          if (z === 1 || z === 2) s += 1;
          return s;
        };
        for (const p of pieces) {
          const v = vals[p.t] || 0;
          const side = (p.color === color) ? 1 : -1;
          // material is primary
          score += side * v * 1000;
          // central control bonus scaled by piece strength
          const cent = centrality(p.x, p.y, p.z);
          score += side * v * 40 * cent;
          // explicit larger bonus for occupying the central 8 squares and for controlling them
          try {
            const key = `${p.x},${p.y},${p.z}`;
            if (central8.has(key)) {
              // occupying a central square is valuable; pawns get extra incentive
              const occBonus = p.t === 'p' ? 900 : 500;
              score += side * occBonus;
            }
          } catch (e) {}
          // safety: penalize pieces that are attacked more times than defended
          try {
            const attackers = attackersOfSquare(pieces, p.x, p.y, p.z).filter(a => a.color !== p.color).length;
            const defenders = attackersOfSquare(pieces, p.x, p.y, p.z).filter(a => a.color === p.color).length;
            if (attackers > defenders) {
              const diff = attackers - defenders;
              // penalize proportionally to piece value and number of attackers
              score -= side * v * 400 * diff;
            }
          } catch (e) {}
        }
        // mobility and pawn structure: mobility small bonus
        try {
          const myMoves = getAllLegalMoves(pieces, color) || [];
          const oppMoves = getAllLegalMoves(pieces, color === 'white' ? 'black' : 'white') || [];
          score += (myMoves.length - oppMoves.length) * 12;
        } catch (e) {}
          // control of central 8: reward having attackers on those squares
          try {
            let centralControl = 0;
            for (const sq of Array.from(central8)) {
              const [cx, cy, cz] = sq.split(',').map(Number);
              const attackers = attackersOfSquare(pieces, cx, cy, cz).filter(a => a.color === color).length;
              const enemyAttackers = attackersOfSquare(pieces, cx, cy, cz).filter(a => a.color !== color).length;
              centralControl += (attackers - enemyAttackers);
            }
            score += centralControl * 220; // moderate bonus per net attacker
          } catch (e) {}
        // tactical scan: detect if opponent has a fork (attack >=2 high-value pieces) and penalize
        try {
          const opponent = color === 'white' ? 'black' : 'white';
          const oppMoves = getAllLegalMoves(pieces, opponent) || [];
          let forkThreat = false;
          for (const m of oppMoves) {
            try {
              const next = simulateMove(pieces, m.moverId, { x: m.x, y: m.y, z: m.z });
              let attackedHigh = 0;
              for (const p of next) {
                if (p.color !== color) continue;
                if (!(p.t === 'N' || p.t === 'B' || p.t === 'R' || p.t === 'Q')) continue;
                const attackers = attackersOfSquare(next, p.x, p.y, p.z).filter(a => a.color !== p.color).length;
                if (attackers > 0) attackedHigh++;
                if (attackedHigh >= 2) break;
              }
              if (attackedHigh >= 2) { forkThreat = true; break; }
            } catch (e) {}
          }
          if (forkThreat) score -= 2500; // heavy penalty for allowing forks
        } catch (e) {}
        return score;
      }, [getAllLegalMoves, simulateMove, attackersOfSquare]);

      // search timing and state
      const searchStateRef = useRef({ endTime: 0 });

      // helper: order moves (captures first, then center-oriented), prefer moves that reduce undefended pieces
      const orderMoves = useCallback((moves, pieces, side) => {
        const vals = { p: 1, N: 3, B: 3, R: 5, Q: 9 };
        const centerFactor = (m) => -(Math.abs(m.x - 3.5) + Math.abs(m.y - 1.5));
        const central8 = new Set(['3,1,1','4,1,1','3,2,1','4,2,1','3,1,2','4,1,2','3,2,2','4,2,2']);
        // precompute currently-attacked own pieces for defensive bonuses
        const attackedNow = (pieces || []).filter(p => p.color === side).map(p => {
          const attackers = attackersOfSquare(pieces, p.x, p.y, p.z).filter(a => a.color !== p.color).length;
          const defenders = attackersOfSquare(pieces, p.x, p.y, p.z).filter(a => a.color === p.color).length;
          return { id: p.id, x: p.x, y: p.y, z: p.z, attackers, defenders };
        });
        return moves.slice().sort((a, b) => {
          const occA = (pieces || []).find(pp => pp.x === a.x && pp.y === a.y && pp.z === a.z && pp.color !== side);
          const occB = (pieces || []).find(pp => pp.x === b.x && pp.y === b.y && pp.z === b.z && pp.color !== side);
          const capA = occA ? (vals[occA.t] || 0) * 100 : 0;
          const capB = occB ? (vals[occB.t] || 0) * 100 : 0;
          let scoreA = capA + centerFactor(a);
          let scoreB = capB + centerFactor(b);
          try {
            // simulate and penalize moves that leave more undefended own pieces
            const nextA = simulateMove(pieces, a.moverId, { x: a.x, y: a.y, z: a.z });
            const nextB = simulateMove(pieces, b.moverId, { x: b.x, y: b.y, z: b.z });
            const countUndef = (arr, who) => {
              let cnt = 0;
              for (const p of arr) {
                if (p.color !== who) continue;
                const attackers = attackersOfSquare(arr, p.x, p.y, p.z).filter(x => x.color !== p.color).length;
                const defenders = attackersOfSquare(arr, p.x, p.y, p.z).filter(x => x.color === p.color).length;
                if (attackers > defenders) cnt++;
              }
              return cnt;
            };
            const undefA = countUndef(nextA, side);
            const undefB = countUndef(nextB, side);
            // penalize more undefended pieces
            scoreA -= undefA * 500;
            scoreB -= undefB * 500;
            // detect opponent's last mover/capture using prevPiecesRef so we can prefer immediate recaptures/follow-ups
            try {
              const prev = (prevPiecesRef && prevPiecesRef.current) ? prevPiecesRef.current : [];
              let movedList = [];
              for (const p of pieces) {
                try {
                  const pv = prev.find(pp => pp.id === p.id) || null;
                  if (!pv || pv.x !== p.x || pv.y !== p.y || pv.z !== p.z) movedList.push({ before: pv, after: p });
                } catch (e) {}
              }
              const lastMover = (movedList.length > 0) ? movedList[movedList.length - 1].after : null;
              // find any piece that disappeared (captured) from prev to pieces
              let lastCaptured = null;
              for (const pv of prev) {
                try { if (!pieces.find(pp => pp.id === pv.id)) { lastCaptured = pv; break; } } catch (e) {}
              }
              if (lastMover && lastMover.color !== side) {
                try {
                  // if candidate captures the last mover directly, prioritize it
                  if (a.x === lastMover.x && a.y === lastMover.y && a.z === lastMover.z) { scoreA += 4200; try { console.debug('orderMoves: prefer capturing last mover', a, lastMover); } catch(e){} }
                  if (b.x === lastMover.x && b.y === lastMover.y && b.z === lastMover.z) { scoreB += 4200; try { console.debug('orderMoves: prefer capturing last mover', b, lastMover); } catch(e){} }
                  // also reward moves that increase our attackers on that square
                  try {
                    const afterAattackers = attackersOfSquare(nextA, lastMover.x, lastMover.y, lastMover.z).filter(x => x.color === side).length;
                    const afterBattackers = attackersOfSquare(nextB, lastMover.x, lastMover.y, lastMover.z).filter(x => x.color === side).length;
                    if (afterAattackers > 0) { scoreA += afterAattackers * 900; try { console.debug('orderMoves: increases attackers on lastMover square', a, afterAattackers); } catch(e){} }
                    if (afterBattackers > 0) { scoreB += afterBattackers * 900; try { console.debug('orderMoves: increases attackers on lastMover square', b, afterBattackers); } catch(e){} }
                  } catch (e) {}
                } catch (e) {}
              }
            } catch (e) {}
            // discourage early queen moves (rule of thumb: avoid moving queen in the opening)
            try {
              const ply = (moveHistory && moveHistory.length) ? moveHistory.length * 2 : 0;
              const earlyQueenPenalty = (ply < 30) ? 2500 : 1200; // stronger early penalty for queen moves
              const moverA = (pieces || []).find(pp => pp.id === a.moverId);
              const moverB = (pieces || []).find(pp => pp.id === b.moverId);
              if (moverA && moverA.t === 'Q' && capA === 0) { scoreA -= earlyQueenPenalty; try { console.debug('orderMoves: early queen penalty applied', a, earlyQueenPenalty); } catch(e){} }
              if (moverB && moverB.t === 'Q' && capB === 0) { scoreB -= earlyQueenPenalty; try { console.debug('orderMoves: early queen penalty applied', b, earlyQueenPenalty); } catch(e){} }
              // discourage early rook moves unless capturing or they materially improve mobility
              const earlyRookPenalty = (ply < 30) ? 1200 : 600; // stronger early penalty
              if (moverA && moverA.t === 'R' && capA === 0) {
                // measure mobility improvement -- if small, apply extra penalty
                try {
                  const myMovesBefore = (getAllLegalMoves(pieces, side) || []).length;
                  const myMovesAfter = (getAllLegalMoves(nextA, side) || []).length;
                  const mobilityDelta = myMovesAfter - myMovesBefore;
                  if (mobilityDelta < 2) scoreA -= earlyRookPenalty + 600; else scoreA -= earlyRookPenalty;
                } catch (e) { scoreA -= earlyRookPenalty; }
                try {
                  // additional: penalize moving rook off an open file or losing file control
                  const rook = (pieces || []).find(pp => pp.id === a.moverId);
                  if (rook && rook.t === 'R') {
                    // file = y coordinate; open file = no pawns on that y
                    const pawnsOnFile = (pieces || []).filter(p => p.t === 'p' && p.y === rook.y).length;
                    const movesBeforeRook = (getAllLegalMoves(pieces, side) || []).filter(mv => mv.moverId === rook.id).length;
                    const movesAfterRook = (getAllLegalMoves(nextA, side) || []).filter(mv => mv.moverId === rook.id).length;
                    if (pawnsOnFile === 0 && a.y !== rook.y) {
                      scoreA -= 3000;
                      try { console.debug('orderMoves: penalize rook moving off open file', a, { pawnsOnFile, movesBeforeRook, movesAfterRook }); } catch(e){}
                    } else if (movesAfterRook < movesBeforeRook && movesBeforeRook >= 3) {
                      scoreA -= 1200;
                      try { console.debug('orderMoves: penalize rook mobility loss', a, { movesBeforeRook, movesAfterRook }); } catch(e){}
                    }
                    // penalize moving rook from back rank early
                    try {
                      const backRankX = (rook.color === 'white') ? 7 : 0;
                      if (rook.x === backRankX && a.x !== backRankX && (moveHistory && moveHistory.length) && moveHistory.length < 20) {
                        scoreA -= 1000;
                        try { console.debug('orderMoves: penalize early back-rank rook move', a, { rookBeforeX: rook.x }); } catch(e){}
                      }
                    } catch (e) {}
                  }
                } catch (e) {}
              }
              if (moverB && moverB.t === 'R' && capB === 0) {
                try {
                  const myMovesBefore = (getAllLegalMoves(pieces, side) || []).length;
                  const myMovesAfter = (getAllLegalMoves(nextB, side) || []).length;
                  const mobilityDelta = myMovesAfter - myMovesBefore;
                  if (mobilityDelta < 2) scoreB -= earlyRookPenalty + 600; else scoreB -= earlyRookPenalty;
                } catch (e) { scoreB -= earlyRookPenalty; }
                try {
                  const rook = (pieces || []).find(pp => pp.id === b.moverId);
                  if (rook && rook.t === 'R') {
                    const pawnsOnFile = (pieces || []).filter(p => p.t === 'p' && p.y === rook.y).length;
                    const movesBeforeRook = (getAllLegalMoves(pieces, side) || []).filter(mv => mv.moverId === rook.id).length;
                    const movesAfterRook = (getAllLegalMoves(nextB, side) || []).filter(mv => mv.moverId === rook.id).length;
                    if (pawnsOnFile === 0 && b.y !== rook.y) {
                      scoreB -= 3000;
                      try { console.debug('orderMoves: penalize rook moving off open file', b, { pawnsOnFile, movesBeforeRook, movesAfterRook }); } catch(e){}
                    } else if (movesAfterRook < movesBeforeRook && movesBeforeRook >= 3) {
                      scoreB -= 1200;
                      try { console.debug('orderMoves: penalize rook mobility loss', b, { movesBeforeRook, movesAfterRook }); } catch(e){}
                    }
                    try {
                      const backRankX = (rook.color === 'white') ? 7 : 0;
                      if (rook.x === backRankX && b.x !== backRankX && (moveHistory && moveHistory.length) && moveHistory.length < 20) {
                        scoreB -= 1000;
                        try { console.debug('orderMoves: penalize early back-rank rook move', b, { rookBeforeX: rook.x }); } catch(e){}
                      }
                    } catch (e) {}
                  }
                } catch (e) {}
              }
              // discourage early knight sorties if pawns haven't supported center (prefer pawn moves first)
              try {
                const pawnMovedCount = (pieces || []).filter(p => p.color === side && p.t === 'p' && p.hasMoved).length;
                const knightEarlyPenalty = (ply < 20 && pawnMovedCount < 2) ? 700 : 0;
                if (moverA && moverA.t === 'N' && capA === 0) scoreA -= knightEarlyPenalty;
                if (moverB && moverB.t === 'N' && capB === 0) scoreB -= knightEarlyPenalty;
                // discourage early king moves (except castling) strongly in opening unless they clearly improve safety
                try {
                  const kingEarlyCutoff = 20; // ply cutoff
                  const kingPenaltyBase = 10000;
                  const moverA_k = (pieces || []).find(pp => pp.id === a.moverId);
                  const moverB_k = (pieces || []).find(pp => pp.id === b.moverId);
                  if (ply < kingEarlyCutoff) {
                    if (moverA_k && moverA_k.t === 'K') {
                      const isCastle = Math.abs((a.y || 0) - (moverA_k.y || 0)) === 2;
                      if (!isCastle) {
                        try {
                          const attackersBefore = attackersOfSquare(pieces, moverA_k.x, moverA_k.y, moverA_k.z).filter(x => x.color !== side).length;
                          const attackersAfter = attackersOfSquare(nextA, a.x, a.y, a.z).filter(x => x.color !== side).length;
                          if (attackersAfter >= attackersBefore) {
                            scoreA -= kingPenaltyBase; // heavily discourage aimless king moves
                          } else {
                            scoreA -= Math.floor(kingPenaltyBase / 4); // small penalty even if it improves safety
                          }
                        } catch (e) { scoreA -= kingPenaltyBase; }
                      }
                    }
                    if (moverB_k && moverB_k.t === 'K') {
                      const isCastleB = Math.abs((b.y || 0) - (moverB_k.y || 0)) === 2;
                      if (!isCastleB) {
                        try {
                          const attackersBeforeB = attackersOfSquare(pieces, moverB_k.x, moverB_k.y, moverB_k.z).filter(x => x.color !== side).length;
                          const attackersAfterB = attackersOfSquare(nextB, b.x, b.y, b.z).filter(x => x.color !== side).length;
                          if (attackersAfterB >= attackersBeforeB) {
                            scoreB -= kingPenaltyBase;
                          } else {
                            scoreB -= Math.floor(kingPenaltyBase / 4);
                          }
                        } catch (e) { scoreB -= kingPenaltyBase; }
                      }
                    }
                  }
                } catch (e) {}
                // discourage moving the same minor piece twice in the opening (first 10 full moves)
                try {
                  const openingMinorPenalty = (ply < 20) ? 1800 : 800;
                  if (moverA && (moverA.t === 'N' || moverA.t === 'B') && moverA.hasMoved) {
                    scoreA -= openingMinorPenalty;
                    try { console.debug('orderMoves: penalize minor-piece moving twice in opening', a, openingMinorPenalty); } catch(e){}
                  }
                  if (moverB && (moverB.t === 'N' || moverB.t === 'B') && moverB.hasMoved) {
                    scoreB -= openingMinorPenalty;
                    try { console.debug('orderMoves: penalize minor-piece moving twice in opening', b, openingMinorPenalty); } catch(e){}
                  }
                } catch (e) {}
              } catch (e) {}
            } catch (e) {}
            // prefer castling moves
            try {
              if (a.castle) scoreA += 700;
              if (b.castle) scoreB += 700;
            } catch (e) {}
            // favor moves that occupy or increase control of central-8 squares
            try {
              const aKey = `${a.x},${a.y},${a.z}`;
              const bKey = `${b.x},${b.y},${b.z}`;
              if (central8.has(aKey)) { scoreA += 900; try { console.debug('orderMoves: central8 occupy bonus for move', a); } catch(e){} }
              if (central8.has(bKey)) { scoreB += 900; try { console.debug('orderMoves: central8 occupy bonus for move', b); } catch(e){} }
              // also reward moves that increase net attackers on central squares
              try {
                const nextA = simulateMove(pieces, a.moverId, { x: a.x, y: a.y, z: a.z });
                const nextB = simulateMove(pieces, b.moverId, { x: b.x, y: b.y, z: b.z });
                let deltaA = 0, deltaB = 0;
                for (const sq of Array.from(central8)) {
                  const [cx, cy, cz] = sq.split(',').map(Number);
                  const before = attackersOfSquare(pieces, cx, cy, cz).filter(x => x.color === side).length - attackersOfSquare(pieces, cx, cy, cz).filter(x => x.color !== side).length;
                  const afterA = attackersOfSquare(nextA, cx, cy, cz).filter(x => x.color === side).length - attackersOfSquare(nextA, cx, cy, cz).filter(x => x.color !== side).length;
                  const afterB = attackersOfSquare(nextB, cx, cy, cz).filter(x => x.color === side).length - attackersOfSquare(nextB, cx, cy, cz).filter(x => x.color !== side).length;
                  deltaA += (afterA - before);
                  deltaB += (afterB - before);
                }
                scoreA += deltaA * 220;
                scoreB += deltaB * 220;
                if (deltaA > 0) try { console.debug('orderMoves: increased central control by', deltaA, 'for', a); } catch(e) {}
                if (deltaB > 0) try { console.debug('orderMoves: increased central control by', deltaB, 'for', b); } catch(e) {}
              } catch (e) {}
              // if opponent just moved a pawn into central-8, prioritize moves that contest or defend it
              try {
                if (typeof lastMove !== 'undefined' && lastMove && lastMove.to) {
                  const lm = lastMove.to;
                  const lmKey = `${lm.x},${lm.y},${lm.z}`;
                  const oppPawnThere = (pieces || []).find(pp => pp.x === lm.x && pp.y === lm.y && pp.z === lm.z && pp.t === 'p' && pp.color !== side);
                  if (central8.has(lmKey) && oppPawnThere) {
                    // capturing that pawn is highest priority
                    if (a.x === lm.x && a.y === lm.y && a.z === lm.z) { scoreA += 8000; try { console.debug('orderMoves: capture central pawn priority', a); } catch(e){} }
                    if (b.x === lm.x && b.y === lm.y && b.z === lm.z) { scoreB += 8000; try { console.debug('orderMoves: capture central pawn priority', b); } catch(e){} }
                    // moving own pawn into central-8 to contest
                    if ((pieces || []).find(pp => pp.id === a.moverId && pp.t === 'p')) {
                      const aKey2 = `${a.x},${a.y},${a.z}`;
                      if (central8.has(aKey2)) { scoreA += 5000; try { console.debug('orderMoves: pawn contest central8 bonus', a); } catch(e){} }
                      // pawn approach bonus: reward pawn moves that move closer to any central8 square
                      try {
                        const pawnBefore = (pieces || []).find(pp => pp.id === a.moverId);
                        if (pawnBefore) {
                          let beforeDist = Infinity, afterDist = Infinity;
                          for (const sq of Array.from(central8)) {
                            const [cx, cy, cz] = sq.split(',').map(Number);
                            const dBefore = Math.abs(pawnBefore.x - cx) + Math.abs(pawnBefore.y - cy) + Math.abs(pawnBefore.z - cz);
                            const dAfter = Math.abs(a.x - cx) + Math.abs(a.y - cy) + Math.abs(a.z - cz);
                            if (dBefore < beforeDist) beforeDist = dBefore;
                            if (dAfter < afterDist) afterDist = dAfter;
                          }
                          const delta = beforeDist - afterDist;
                          if (delta > 0) { scoreA += delta * 1600; try { console.debug('orderMoves: pawn approach central8 bonus', a, delta); } catch(e){} }
                        }
                      } catch (e) {}
                    }
                    if ((pieces || []).find(pp => pp.id === b.moverId && pp.t === 'p')) {
                      const bKey2 = `${b.x},${b.y},${b.z}`;
                      if (central8.has(bKey2)) { scoreB += 5000; try { console.debug('orderMoves: pawn contest central8 bonus', b); } catch(e){} }
                      try {
                        const pawnBefore = (pieces || []).find(pp => pp.id === b.moverId);
                        if (pawnBefore) {
                          let beforeDist = Infinity, afterDist = Infinity;
                          for (const sq of Array.from(central8)) {
                            const [cx, cy, cz] = sq.split(',').map(Number);
                            const dBefore = Math.abs(pawnBefore.x - cx) + Math.abs(pawnBefore.y - cy) + Math.abs(pawnBefore.z - cz);
                            const dAfter = Math.abs(b.x - cx) + Math.abs(b.y - cy) + Math.abs(b.z - cz);
                            if (dBefore < beforeDist) beforeDist = dBefore;
                            if (dAfter < afterDist) afterDist = dAfter;
                          }
                          const delta = beforeDist - afterDist;
                          if (delta > 0) { scoreB += delta * 1600; try { console.debug('orderMoves: pawn approach central8 bonus', b, delta); } catch(e){} }
                        }
                      } catch (e) {}
                    }
                    // rewarding moves that increase defenders on that pawn
                    try {
                      const beforeDef = attackersOfSquare(pieces, lm.x, lm.y, lm.z).filter(a2 => a2.color === oppPawnThere.color).length;
                      const nextA2 = simulateMove(pieces, a.moverId, { x: a.x, y: a.y, z: a.z });
                      const nextB2 = simulateMove(pieces, b.moverId, { x: b.x, y: b.y, z: b.z });
                      const defA = attackersOfSquare(nextA2, lm.x, lm.y, lm.z).filter(a2 => a2.color === oppPawnThere.color).length;
                      const defB = attackersOfSquare(nextB2, lm.x, lm.y, lm.z).filter(a2 => a2.color === oppPawnThere.color).length;
                      // if our move increases attackers of that pawn by our side (i.e., we defend it), give bonus
                      const ourBefore = attackersOfSquare(pieces, lm.x, lm.y, lm.z).filter(a2 => a2.color === side).length;
                      const ourAfterA = attackersOfSquare(nextA2, lm.x, lm.y, lm.z).filter(a2 => a2.color === side).length;
                      const ourAfterB = attackersOfSquare(nextB2, lm.x, lm.y, lm.z).filter(a2 => a2.color === side).length;
                      const deltaOurA = ourAfterA - ourBefore;
                      const deltaOurB = ourAfterB - ourBefore;
                      if (deltaOurA > 0) { scoreA += deltaOurA * 2500; try { console.debug('orderMoves: defend opponent-central-pawn? increased our defenders by', deltaOurA, a); } catch(e){} }
                      if (deltaOurB > 0) { scoreB += deltaOurB * 2500; try { console.debug('orderMoves: defend opponent-central-pawn? increased our defenders by', deltaOurB, b); } catch(e){} }
                    } catch (e) {}
                  }
                }
              } catch (e) {}
            } catch (e) {}
            // avoid early non-capturing king moves unless in check
            try {
              const inCheck = isAnyKingInCheck(pieces, side);
              const moverA = (pieces || []).find(pp => pp.id === a.moverId);
              const moverB = (pieces || []).find(pp => pp.id === b.moverId);
              if (moverA && moverA.t === 'K' && !occA && !inCheck) scoreA -= 12000;
              if (moverB && moverB.t === 'K' && !occB && !inCheck) scoreB -= 12000;
              // extra: penalize king moves that reduce mobility or central presence when not capturing
              try {
                if (moverA && moverA.t === 'K' && !occA && !inCheck) {
                  const beforeMob = (getAllLegalMoves(pieces, side) || []).filter(mv => mv.moverId === moverA.id).length;
                  const afterA = simulateMove(pieces, a.moverId, { x: a.x, y: a.y, z: a.z });
                  const afterMob = (getAllLegalMoves(afterA, side) || []).filter(mv => mv.moverId === moverA.id).length;
                  const mobDelta = afterMob - beforeMob;
                  const beforeCent = Math.abs(moverA.x - 3.5) + Math.abs(moverA.y - 1.5);
                  const afterCent = Math.abs(a.x - 3.5) + Math.abs(a.y - 1.5);
                  if (mobDelta < 0 || afterCent > beforeCent) { scoreA -= 3000; try { console.debug('orderMoves: penalize king retreat/mobility loss', { move: a, mobDelta, beforeCent, afterCent }); } catch(e){} }
                }
                if (moverB && moverB.t === 'K' && !occB && !inCheck) {
                  const beforeMob = (getAllLegalMoves(pieces, side) || []).filter(mv => mv.moverId === moverB.id).length;
                  const afterB = simulateMove(pieces, b.moverId, { x: b.x, y: b.y, z: b.z });
                  const afterMob = (getAllLegalMoves(afterB, side) || []).filter(mv => mv.moverId === moverB.id).length;
                  const mobDelta = afterMob - beforeMob;
                  const beforeCent = Math.abs(moverB.x - 3.5) + Math.abs(moverB.y - 1.5);
                  const afterCent = Math.abs(b.x - 3.5) + Math.abs(b.y - 1.5);
                  if (mobDelta < 0 || afterCent > beforeCent) { scoreB -= 3000; try { console.debug('orderMoves: penalize king retreat/mobility loss', { move: b, mobDelta, beforeCent, afterCent }); } catch(e){} }
                }
              } catch (e) {}
            } catch (e) {}
            // prioritize immediate recapture of last moved-to square
            try {
              if (typeof lastMove !== 'undefined' && lastMove && lastMove.to) {
                const lx = lastMove.to.x, ly = lastMove.to.y, lz = lastMove.to.z;
                // require tactical sanity: only heavily prefer recapture if SEE is non-negative.
                try {
                  if (a.x === lx && a.y === ly && a.z === lz) {
                    try {
                      const seeA = staticExchangeEval(pieces, lx, ly, lz, side);
                      const moverA = (pieces || []).find(pp => pp.id === a.moverId) || null;
                      if (seeA >= 0) scoreA += 5000;
                      else {
                        if (moverA && (moverA.t === 'R' || moverA.t === 'Q')) scoreA -= 4000; else scoreA += 200;
                        try { console.debug('orderMoves: recapture discouraged by SEE', { move: a, seeA, mover: moverA && moverA.t }); } catch(e){}
                      }
                    } catch (e) { scoreA += 0; }
                  }
                } catch (e) {}
                try {
                  if (b.x === lx && b.y === ly && b.z === lz) {
                    try {
                      const seeB = staticExchangeEval(pieces, lx, ly, lz, side);
                      const moverB = (pieces || []).find(pp => pp.id === b.moverId) || null;
                      if (seeB >= 0) scoreB += 5000;
                      else {
                        if (moverB && (moverB.t === 'R' || moverB.t === 'Q')) scoreB -= 4000; else scoreB += 200;
                        try { console.debug('orderMoves: recapture discouraged by SEE', { move: b, seeB, mover: moverB && moverB.t }); } catch(e){}
                      }
                    } catch (e) { scoreB += 0; }
                  }
                } catch (e) {}
              }
            } catch (e) {}
            // reward moves that improve defenders on currently-attacked own pieces
            try {
              const defenderBonus = (m) => {
                let bonus = 0;
                try {
                  const next = simulateMove(pieces, m.moverId, { x: m.x, y: m.y, z: m.z });
                  for (const at of attackedNow) {
                    const afterOcc = next.find(pp => pp.id === at.id);
                    if (!afterOcc) continue; // captured
                    const attackersAfter = attackersOfSquare(next, afterOcc.x, afterOcc.y, afterOcc.z).filter(a => a.color !== afterOcc.color).length;
                    const defendersAfter = attackersOfSquare(next, afterOcc.x, afterOcc.y, afterOcc.z).filter(a => a.color === afterOcc.color).length;
                    // if defenders increased or attackers decreased, give bonus
                    if (defendersAfter > at.defenders) bonus += 400;
                    if (attackersAfter < at.attackers) bonus += 300;
                  }
                } catch (e) {}
                return bonus;
              };
              scoreA += defenderBonus(a);
              scoreB += defenderBonus(b);
            } catch (e) {}
            // If we have high-value own pieces currently attacked (B/N/R/Q), prefer moves that address them.
            try {
              const attackedHigh = (pieces || []).filter(p => p.color === side && (p.t === 'B' || p.t === 'N' || p.t === 'R' || p.t === 'Q')).map(p => {
                const attackers = attackersOfSquare(pieces, p.x, p.y, p.z).filter(a => a.color !== p.color);
                const defenders = attackersOfSquare(pieces, p.x, p.y, p.z).filter(a => a.color === p.color);
                return { id: p.id, x: p.x, y: p.y, z: p.z, t: p.t, attackers: attackers, defenders: defenders };
              }).filter(h => h.attackers.length > h.defenders.length);
              if (attackedHigh && attackedHigh.length > 0) {
                const addressesThreat = (move, attackedList) => {
                  try {
                    const next = simulateMove(pieces, move.moverId, { x: move.x, y: move.y, z: move.z });
                    for (const hp of attackedList) {
                      // if our move captures one of the attackers, that's good
                      const attackersNow = attackersOfSquare(pieces, hp.x, hp.y, hp.z).filter(a => a.color !== hp.color);
                      for (const at of attackersNow) {
                        if (move.x === at.x && move.y === at.y && move.z === at.z) return true;
                      }
                      // if the threatened piece itself moved to safety
                      if (move.moverId === hp.id) {
                        const occAfter = next.find(pp => pp.id === hp.id);
                        if (!occAfter) return true; // moved/captured
                        const atkAfter = attackersOfSquare(next, occAfter.x, occAfter.y, occAfter.z).filter(a => a.color !== occAfter.color).length;
                        const defAfter = attackersOfSquare(next, occAfter.x, occAfter.y, occAfter.z).filter(a => a.color === occAfter.color).length;
                        if (defAfter >= atkAfter) return true;
                      }
                      // if our move increases defenders on threatened piece
                      const occAfter2 = next.find(pp => pp.id === hp.id);
                      if (occAfter2) {
                        const defAfter2 = attackersOfSquare(next, occAfter2.x, occAfter2.y, occAfter2.z).filter(a => a.color === occAfter2.color).length;
                        if (defAfter2 > hp.defenders.length) return true;
                      } else {
                        // piece disappeared (captured) - not good
                        return false;
                      }
                      // if our move captures the attacking piece by moving to their square
                    }
                  } catch (e) {}
                  return false;
                };
                try {
                  if (!addressesThreat(a, attackedHigh)) { scoreA -= 2000; try { console.debug('orderMoves: penalize move that ignores attacked high-value piece', a, attackedHigh); } catch(e){} }
                  if (!addressesThreat(b, attackedHigh)) { scoreB -= 2000; try { console.debug('orderMoves: penalize move that ignores attacked high-value piece', b, attackedHigh); } catch(e){} }
                } catch (e) {}
              }
            } catch (e) {}
            // reward moves that increase minor-piece mobility (knights and bishops)
            try {
              const minorMobility = (state, sideColor) => {
                let cnt = 0;
                for (const p of (state || [])) {
                  if (p.color !== sideColor) continue;
                  if (p.t !== 'N' && p.t !== 'B') continue;
                  try { cnt += (getAllLegalMoves(state, sideColor) || []).filter(mv => mv.moverId === p.id).length; } catch(e){}
                }
                return cnt;
              };
              try {
                const beforeMinor = (() => {
                  let c = 0; try { c = minorMobility(pieces, side); } catch(e){} return c;
                })();
                const afterA = (() => { try { return minorMobility(simulateMove(pieces, a.moverId, { x: a.x, y: a.y, z: a.z }), side); } catch(e){return 0;} })();
                const afterB = (() => { try { return minorMobility(simulateMove(pieces, b.moverId, { x: b.x, y: b.y, z: b.z }), side); } catch(e){return 0;} })();
                const deltaA = afterA - beforeMinor;
                const deltaB = afterB - beforeMinor;
                if (deltaA > 0) { scoreA += deltaA * 450; try { console.debug('orderMoves: minor mobility bonus', a, deltaA); } catch(e){} }
                if (deltaB > 0) { scoreB += deltaB * 450; try { console.debug('orderMoves: minor mobility bonus', b, deltaB); } catch(e){} }
              } catch (e){}
            } catch (e) {}
            // encourage pawn moves that open diagonals for bishops (development)
            try {
              const isPawnOpenForBishop = (move) => {
                try {
                  const mover = (pieces || []).find(pp => pp.id === move.moverId);
                  if (!mover || mover.t !== 'p') return 0;
                  const next = simulateMove(pieces, mover.id, { x: move.x, y: move.y, z: move.z });
                  // for each friendly bishop, count their legal moves before/after
                  let delta = 0;
                  for (const b of (pieces || []).filter(p => p.color === side && p.t === 'B')) {
                    const before = (getAllLegalMoves(pieces, side) || []).filter(mv=>mv.moverId===b.id).length;
                    const after = (getAllLegalMoves(next, side) || []).filter(mv=>mv.moverId===b.id).length;
                    delta += (after - before);
                  }
                  return delta;
                } catch (e) { return 0; }
              };
              const pawnOpenA = isPawnOpenForBishop(a);
              const pawnOpenB = isPawnOpenForBishop(b);
              if (pawnOpenA > 0) { scoreA += pawnOpenA * 700; try { console.debug('orderMoves: pawn move opens bishop mobility', a, pawnOpenA); } catch(e){} }
              if (pawnOpenB > 0) { scoreB += pawnOpenB * 700; try { console.debug('orderMoves: pawn move opens bishop mobility', b, pawnOpenB); } catch(e){} }
            } catch (e) {}
            // prefer favorable trades: use SEE to prefer captures that are non-negative
            try {
              if (occA) {
                try {
                  const seeA = staticExchangeEval(pieces, a.x, a.y, a.z, side);
                  if (seeA >= 0) {
                    scoreA += 1200;
                    try { console.debug('orderMoves: favorable trade (SEE) for', a, seeA); } catch(e){}
                  } else {
                    // penalize unsafe bishop/knight captures when SEE is negative (avoid cheap sacrifices)
                    const moverA = (pieces || []).find(pp => pp.id === a.moverId) || null;
                    if (moverA && (moverA.t === 'B' || moverA.t === 'N')) {
                      scoreA -= 3000;
                      try { console.debug('orderMoves: penalize unsafe minor-piece capture by SEE', a, seeA, moverA.t); } catch(e){}
                    }
                  }
                } catch (e) {}
              }
              if (occB) {
                try {
                  const seeB = staticExchangeEval(pieces, b.x, b.y, b.z, side);
                  if (seeB >= 0) {
                    scoreB += 1200;
                    try { console.debug('orderMoves: favorable trade (SEE) for', b, seeB); } catch(e){}
                  } else {
                    const moverB = (pieces || []).find(pp => pp.id === b.moverId) || null;
                    if (moverB && (moverB.t === 'B' || moverB.t === 'N')) {
                      scoreB -= 3000;
                      try { console.debug('orderMoves: penalize unsafe minor-piece capture by SEE', b, seeB, moverB.t); } catch(e){}
                    }
                  }
                } catch (e) {}
              }
            } catch (e) {}
          } catch (e) {}
          return scoreB - scoreA;
        });
      }, [simulateMove, attackersOfSquare, moveHistory, lastMove, getAllLegalMoves]);
      // helper: perform a move programmatically (moverId + target)
      const applyMove = useCallback((moverId, finalTarget) => {
        try { console.debug('applyMove enter', { moverId, finalTarget, moveLock: moveLockRef.current }); } catch (e) {}
        if (moveLockRef.current) { try { console.debug('applyMove early return: moveLock active', { moverId }); } catch (e) {} return; }
        moveLockRef.current = true;
        try { (typeof pushStateSnapshot !== 'undefined') && pushStateSnapshot(); } catch (e) {}
        try {
          // compute stable snapshot and notation BEFORE mutating state to avoid races
          const snapPieces = (prevPiecesRef.current && prevPiecesRef.current.length) ? prevPiecesRef.current : (piecesState || []);
          let moverBeforeSnap = null;
          try { moverBeforeSnap = snapPieces.find(p => p.id === moverId) || null; } catch (e) { moverBeforeSnap = null; }
          let finalNotationComputed = '';
          try {
            // always compute notation from stable pre-move snapshot to avoid races
            finalNotationComputed = generateMoveNotation(moverBeforeSnap, finalTarget, snapPieces) || '';
          } catch (e) { finalNotationComputed = '' }

          // perform state mutation
          setPiecesState((prev) => {
            const mover = prev.find(pp => pp.id === moverId);
            if (!mover) return prev;
            const movingColor = mover.color;
            let withoutCaptured;
            try {
              if (finalTarget && finalTarget.enPassant && finalTarget.capturedId) {
                withoutCaptured = prev.filter(pp => pp.id !== finalTarget.capturedId);
              } else {
                withoutCaptured = prev.filter(pp => !(pp.x === finalTarget.x && pp.y === finalTarget.y && pp.z === finalTarget.z && pp.color !== movingColor));
              }
              const next = withoutCaptured.map((pp) => {
                if (pp.id === moverId) return { ...pp, x: finalTarget.x, y: finalTarget.y, z: finalTarget.z, hasMoved: true };
                if (finalTarget && finalTarget.castle) {
                  // primary: match rook by explicit id
                  if (pp.id === finalTarget.castle.rookId) {
                    const originalRookTo = finalTarget.castle.rookTo;
                    let safeRookTo = originalRookTo;
                    try {
                      if (originalRookTo && finalTarget && typeof finalTarget.x === 'number' && typeof originalRookTo.x === 'number') {
                        if (originalRookTo.x === finalTarget.x && originalRookTo.y === finalTarget.y && originalRookTo.z === finalTarget.z) {
                          safeRookTo = { x: mover.x, y: mover.y, z: mover.z };
                        }
                      }
                    } catch (e) {}
                    if (safeRookTo) return { ...pp, x: safeRookTo.x, y: safeRookTo.y, z: safeRookTo.z, hasMoved: true };
                  }
                  // fallback: if rookId didn't match (possible mismatch), fall back to matching rookFrom coords
                  try {
                    const rf = finalTarget.castle.rookFrom;
                    if (rf && pp.x === rf.x && pp.y === rf.y && pp.z === rf.z) {
                      const originalRookTo = finalTarget.castle.rookTo;
                      let safeRookTo = originalRookTo;
                      try {
                        if (originalRookTo && finalTarget && typeof finalTarget.x === 'number' && typeof originalRookTo.x === 'number') {
                          if (originalRookTo.x === finalTarget.x && originalRookTo.y === finalTarget.y && originalRookTo.z === finalTarget.z) {
                            safeRookTo = { x: mover.x, y: mover.y, z: mover.z };
                          }
                        }
                      } catch (e) {}
                      if (safeRookTo) return { ...pp, x: safeRookTo.x, y: safeRookTo.y, z: safeRookTo.z, hasMoved: true };
                    }
                  } catch (e) {}
                }
                return pp;
              });
              return next;
            } catch (e) { return prev; }
          });

          // notation and history using the precomputed stable notation
          try {
            try { console.debug('applyMove notation computed', { moverId: moverId, moverBefore: moverBeforeSnap, finalTarget, finalNotation: finalNotationComputed }); } catch (e) {}
            if (finalNotationComputed) {
              const side = moverBeforeSnap ? moverBeforeSnap.color : null;
              setMoveHistory(prev => {
                const copy = prev ? prev.slice() : [];
                if (side === 'white') {
                  const last = copy.length ? copy[copy.length - 1] : null;
                  if (last && last.white === finalNotationComputed) return copy;
                  copy.push({ white: finalNotationComputed, black: null });
                } else if (side === 'black') {
                  if (copy.length === 0) copy.push({ white: null, black: finalNotationComputed });
                  else copy[copy.length - 1] = { ...copy[copy.length - 1], black: finalNotationComputed };
                }
                try { console.debug('applyMove moveHistory updated', { beforeLen: prev ? prev.length : 0, afterLen: copy.length, copyLast: copy[copy.length - 1] }); } catch (e) {}
                return copy;
              });
            } else {
              try { console.debug('applyMove: no notation generated', { moverId: moverId, moverBefore: moverBeforeSnap, finalTarget }); } catch (e) {}
            }
          } catch (e) { console.debug('applyMove history error', e); }

          setSelectedPieceId(null);
          setCurrentTurn((prev) => (prev === 'white' ? 'black' : 'white'));

          // set lastMove for double-step pawns based on snapshot mover
          try {
            if (moverBeforeSnap && moverBeforeSnap.t === 'p') {
              const dx = Math.abs(finalTarget.x - moverBeforeSnap.x);
              if (dx === 2) {
                const lm = { id: moverBeforeSnap.id, from: { x: moverBeforeSnap.x, y: moverBeforeSnap.y, z: moverBeforeSnap.z }, to: { x: finalTarget.x, y: finalTarget.y, z: finalTarget.z }, doubleStep: true };
                setLastMove(lm);
              } else setLastMove(null);
            } else setLastMove(null);
          } catch (e) { setLastMove(null); }
        } finally {
          moveLockRef.current = false;
        }
      }, [piecesState, setPiecesState, setMoveHistory, setSelectedPieceId, setCurrentTurn, setLastMove, pushStateSnapshot, generateMoveNotation]);

      // take-back: undo last ply (or last two plies if playing against AI)
      const takeBack = useCallback(() => {
        try {
          if (!statesHistoryRef.current || statesHistoryRef.current.length === 0) return;
          try { console.debug('takeBack invoked, snapshot depth before pop:', statesHistoryRef.current.length, 'aiSide:', aiSide); } catch (e) {}
          const toPop = aiSide ? 2 : 1;
          let restored = null;
          for (let i = 0; i < toPop; i++) {
            if (statesHistoryRef.current.length === 0) break;
            restored = statesHistoryRef.current.pop();
          }
          try { console.debug('takeBack popped, snapshot depth after pop:', statesHistoryRef.current.length); } catch (e) {}
          if (!restored) return;
          try { if (typeof pushDebug === 'function') pushDebug('takeBackPopped', { restoredHas: !!restored, depth: statesHistoryRef.current.length }); } catch (e) {}
          // restore full state
          try { setPiecesState(restored.piecesState || []); } catch (e) {}
          try { setMoveHistory(restored.moveHistory || []); } catch (e) {}
          try { setCurrentTurn(restored.currentTurn || 'white'); } catch (e) {}
          try { setLastMove(restored.lastMove || null); } catch (e) {}
          // also restore aiSide/gameStarted to avoid logic mismatches after undo
          try { setAiSide(restored.aiSide || null); } catch (e) {}
          try { setGameStarted(!!restored.gameStarted); } catch (e) {}
          // update refs to reflect restored state
          try { prevPiecesRef.current = (restored.piecesState || []).map(p => ({ ...p })); } catch (e) {}
          try { prevMoveHistoryRef.current = (restored.moveHistory || []).slice(); } catch (e) {}
          // persist immediately
          try { saveToServerImmediate({ piecesState: restored.piecesState, moveHistory: restored.moveHistory, currentTurn: restored.currentTurn, lastMove: restored.lastMove, aiSide: restored.aiSide, gameStarted: restored.gameStarted }); } catch (e) { console.debug('immediate save after takeBack failed', e); }
          try { console.debug('takeBack restored state', { currentTurn: restored.currentTurn, moveHistoryLen: (restored.moveHistory||[]).length, aiSide: restored.aiSide, gameStarted: restored.gameStarted }); } catch (e) {}
          try { if (typeof pushDebug === 'function') pushDebug('takeBackRestored', { currentTurn: restored.currentTurn, moveHistoryLen: (restored.moveHistory||[]).length, aiSide: restored.aiSide, gameStarted: restored.gameStarted }); } catch (e) {}
        } catch (e) { console.debug('takeBack failed', e); }
      }, [aiSide, gameStarted, saveToServerImmediate]);

      // derive lastMove by diffing piecesState changes so it's always accurate
      useEffect(() => {
        try {
          const prev = prevPiecesRef.current || [];
          const curr = piecesState || [];
          // find moved piece(s)
          const moved = [];
          for (const c of curr) {
            const p = prev.find(pp => pp.id === c.id);
            if (!p) continue;
            if (p.x !== c.x || p.y !== c.y || p.z !== c.z) moved.push({ before: p, after: c });
          }
          if (moved.length === 1) {
            const mv = moved[0];
            if (mv.before.t === 'p' && Math.abs(mv.before.x - mv.after.x) === 2) {
              const lm = { id: mv.after.id, from: { x: mv.before.x, y: mv.before.y, z: mv.before.z }, to: { x: mv.after.x, y: mv.after.y, z: mv.after.z }, doubleStep: true };
              try { setLastMove(lm); console.log('lastMove derived', lm); } catch (e) {}
            } else {
              try { setLastMove(null); } catch (e) {}
            }
          } else {
            try { setLastMove(null); } catch (e) {}
          }
          prevPiecesRef.current = curr.map(c => ({ ...c }));
        } catch (e) {}
      }, [piecesState, setLastMove]);

      // Debug: log entire piecesState and currentTurn when pieces change (helps track unexpected state)
      useEffect(() => {
        try {
          console.debug('piecesState changed. count:', piecesState.length, 'currentTurn:', currentTurn);
          try { pushDebug('piecesStateChanged', { count: piecesState.length, currentTurn }); } catch (e) {}
        } catch (e) {}
      }, [piecesState, currentTurn]);

      useEffect(() => {
        try { pushDebug('moveHistoryChanged', { moveHistory }); } catch (e) {}
      }, [moveHistory]);

      // compute check / checkmate / double-check status whenever board or turn changes
      useEffect(() => {
        try {
          const whiteInCheck = isAnyKingInCheck(piecesState, 'white');
          const blackInCheck = isAnyKingInCheck(piecesState, 'black');
          if (whiteInCheck && blackInCheck) {
            // find attackers for each king
            const whiteKings = piecesState.filter(p => p.t === 'K' && p.color === 'white');
            const blackKings = piecesState.filter(p => p.t === 'K' && p.color === 'black');
            const attackers = [];
            whiteKings.forEach(k => attackers.push(...attackersOfSquare(piecesState, k.x, k.y, k.z)));
            blackKings.forEach(k => attackers.push(...attackersOfSquare(piecesState, k.x, k.y, k.z)));
            const uniqueAttackers = Array.from(new Map(attackers.map(a => [a.id, a])).values());
            const attackerColors = Array.from(new Set(uniqueAttackers.map(a => a.color)));
            if (uniqueAttackers.length > 0 && attackerColors.length === 1) {
              // single-color attacker(s)
              const attackColor = attackerColors[0];
              const capturePossible = canAnyPieceCaptureAttackers(piecesState, uniqueAttackers);
              if (!capturePossible) {
                setGameOver(true);
                setGameWinner(attackColor);
                setStatusMessage(`Double-check: ${attackColor} wins`);
                return;
              }
            }
            // otherwise show check message for both, but don't end game
            setGameOver(false);
            setGameWinner(null);
            setStatusMessage('Double-check');
            return;
          }
          // determine if the side to move is in checkmate
          const sideToMove = currentTurn;
          const sideInCheck = isAnyKingInCheck(piecesState, sideToMove);
          const hasMove = hasAnyLegalMove(piecesState, sideToMove);
          if (sideInCheck && !hasMove) {
            setGameOver(true);
            const winner = sideToMove === 'white' ? 'black' : 'white';
            setGameWinner(winner);
            setStatusMessage(`Checkmate: ${winner} wins`);
            return;
          }
          // normal check notification
          if (whiteInCheck || blackInCheck) {
            if (whiteInCheck) setStatusMessage('Check: white');
            else setStatusMessage('Check: black');
            setGameOver(false);
            setGameWinner(null);
            return;
          }
          // clear status
          setStatusMessage('');
          setGameOver(false);
          setGameWinner(null);
        } catch (e) {}
      }, [piecesState, currentTurn]);

      // camera / controls persistence
      const controlsRef = useRef();
      const importInputRef = useRef(null);
      // prefer explicit saved defaults if present; otherwise fall back to last-used camPos
      const [camPos, setCamPos] = useState(() => {
        try {
          return JSON.parse(localStorage.getItem('camDefaultPos')) || JSON.parse(localStorage.getItem('camPos')) || [6, 5, -8];
        } catch { return [6,5,-8]; }
      });
      const [camTarget, setCamTarget] = useState(() => {
        try {
          return JSON.parse(localStorage.getItem('camDefaultTarget')) || JSON.parse(localStorage.getItem('camTarget')) || [0, 1.7, 0];
        } catch { return [0,1.7,0]; }
      });

      useEffect(() => {
        // apply saved target to controls when they mount
        if (controlsRef.current) {
          const c = controlsRef.current;
          if (c.target && Array.isArray(camTarget)) {
            c.target.set(camTarget[0], camTarget[1], camTarget[2]);
            c.update();
          }
          // ensure camera position if accessible
          if (c.object && Array.isArray(camPos)) {
            c.object.position.set(camPos[0], camPos[1], camPos[2]);
          }
        }
      }, [controlsRef, camPos, camTarget]);

      // R3F helper: directly resize renderer and camera on window resize/unmaximize
      function R3FResize() {
        const { gl, camera } = useThree();
        useEffect(() => {
          const handler = () => {
            try { console.debug('R3FResize handler invoked'); } catch (e) {}
            try {
              const canvas = gl && gl.domElement;
              if (!canvas) return;
              // prefer the main container size to avoid transient zero-width during window transitions
              const main = document.querySelector('.main');
              let w, h;
              if (main) {
                w = Math.max(1, Math.floor(main.clientWidth));
                h = Math.max(1, Math.floor(main.clientHeight));
              } else {
                const rect = canvas.getBoundingClientRect();
                w = Math.max(1, Math.floor(rect.width));
                h = Math.max(1, Math.floor(rect.height));
              }
              // explicitly set renderer size and pixel ratio
              try { gl.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2)); } catch (e) {}
              try { gl.setSize(w, h, false); } catch (e) {}
              // update camera aspect
              if (camera && typeof camera.aspect === 'number') {
                camera.aspect = w / h;
                try { camera.updateProjectionMatrix(); } catch (e) {}
              }
            } catch (e) {}
          };
          window.addEventListener('resize', handler);
          window.addEventListener('chess3d:resize', handler);
          // run a few times to stabilize after layout changes
          try { console.debug('R3FResize mounted'); } catch (e) {}
          setTimeout(handler, 50);
          setTimeout(handler, 200);
          setTimeout(handler, 500);
          return () => { window.removeEventListener('resize', handler); window.removeEventListener('chess3d:resize', handler); };
        }, [gl, camera]);
        return null;
      }

      // remount the Canvas after a resize finishes (debounced) to emulate full-refresh initialization
      useEffect(() => {
        const timer = { id: null };
        const handler = () => {
          try {
            if (timer.id) clearTimeout(timer.id);
            timer.id = setTimeout(() => {
              try { setCanvasKey(k => k + 1); } catch (e) {}
              timer.id = null;
            }, 250);
          } catch (e) {}
        };
        window.addEventListener('resize', handler);
        return () => { window.removeEventListener('resize', handler); if (timer.id) clearTimeout(timer.id); };
      }, []);

      // Persistence helpers
      const SAVE_KEY = 'chess3d:local_state';
      const SERVER_ID_KEY = 'chess3d:server_id';
      const SERVER_TOKEN_KEY = 'chess3d:server_token';

      const exportGame = () => {
        try {
          // build a human-readable move notation array for easier inspection
          const moveNotation = (moveHistory || []).map((mv, idx) => {
            const white = mv && mv.white ? mv.white : '';
            const black = mv && mv.black ? mv.black : '';
            const left = `${idx + 1}. ${white}`.trim();
            return black ? `${left} ${black}` : left;
          });
          const payload = { piecesState, moveHistory, moveNotation, currentTurn, lastMove, aiSide, gameStarted };
          const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `chess3d-save-${new Date().toISOString()}.json`;
          document.body.appendChild(a);
          a.click();
          a.remove();
          URL.revokeObjectURL(url);
        } catch (e) { console.debug('export error', e); }
      };

      const importGame = async (file) => {
        try {
          const text = await file.text();
          const obj = JSON.parse(text);
          if (obj && obj.piecesState) {
            setPiecesState(obj.piecesState);
            setMoveHistory(obj.moveHistory || []);
            setCurrentTurn(obj.currentTurn || 'white');
            setLastMove(obj.lastMove || null);
            try { setAiSide(obj.aiSide || null); } catch (e) {}
            try { setGameStarted(!!obj.gameStarted); } catch (e) {}
            alert('Game imported');
          } else alert('Invalid file');
        } catch (e) { alert('Import failed'); }
      };

      const saveToLocal = () => {
        try {
          const payload = { piecesState, moveHistory, currentTurn, lastMove, aiSide, gameStarted };
          localStorage.setItem(SAVE_KEY, JSON.stringify(payload));
          alert('Saved locally');
        } catch (e) { alert('Local save failed'); }
      };

      const loadFromLocal = () => {
        try {
          const txt = localStorage.getItem(SAVE_KEY);
          if (!txt) { alert('No local save'); return; }
          const obj = JSON.parse(txt);
          setPiecesState(obj.piecesState || []);
          setMoveHistory(obj.moveHistory || []);
          setCurrentTurn(obj.currentTurn || 'white');
          setLastMove(obj.lastMove || null);
          try { setAiSide(obj.aiSide || null); } catch (e) {}
          try { setGameStarted(!!obj.gameStarted); } catch (e) {}
        } catch (e) { alert('Local load failed'); }
      };

      const saveToServer = async () => {
        try {
          const payload = { state: { piecesState, moveHistory, currentTurn, lastMove, aiSide, gameStarted } };
          const existingId = localStorage.getItem(SERVER_ID_KEY);
          const ownerToken = localStorage.getItem(SERVER_TOKEN_KEY);
          if (existingId) {
            // update
            const resp = await fetch(`/api/games/${existingId}`, { method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ state: payload.state, ownerToken }) });
            if (!resp.ok) throw new Error('update failed');
            console.log('Saved to server (updated)');
            return;
          }
          const resp = await fetch('/api/games', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ state: payload.state }) });
          if (!resp.ok) throw new Error('save failed');
          const j = await resp.json();
          if (j.id && j.ownerToken) {
            localStorage.setItem(SERVER_ID_KEY, j.id);
            localStorage.setItem(SERVER_TOKEN_KEY, j.ownerToken);
            console.log(`Saved to server. ID: ${j.id}`);
          }
        } catch (e) { alert('Server save failed'); }
      };

      // immediate save helper that accepts an explicit state object to avoid races
      async function saveToServerImmediate(explicitState) {
        try {
          const payloadState = explicitState || { piecesState, moveHistory, currentTurn, lastMove, aiSide, gameStarted };
          try { console.log('saveToServerImmediate payloadState', payloadState); } catch (e) {}
          const existingId = localStorage.getItem(SERVER_ID_KEY);
          const ownerToken = localStorage.getItem(SERVER_TOKEN_KEY);
          if (existingId) {
            const resp = await fetch(`/api/games/${existingId}`, { method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ state: payloadState, ownerToken }) });
            if (!resp.ok) throw new Error('update failed');
            console.log('Saved to server (updated)');
            return;
          }
          const resp = await fetch('/api/games', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ state: payloadState }) });
          if (!resp.ok) throw new Error('save failed');
          const j = await resp.json();
          if (j.id && j.ownerToken) {
            localStorage.setItem(SERVER_ID_KEY, j.id);
            localStorage.setItem(SERVER_TOKEN_KEY, j.ownerToken);
            console.log(`Saved to server. ID: ${j.id}`);
          }
        } catch (e) { console.debug('server immediate save failed', e); }
      }

      

      // debug: log moveHistory whenever it changes
      useEffect(() => {
        try { console.log('moveHistory state now', moveHistory); } catch (e) {}
      }, [moveHistory]);

      const loadFromServer = async (idPrompt) => {
        try {
          const id = idPrompt || prompt('Enter game id to load:');
          if (!id) return;
          const resp = await fetch(`/api/games/${id}`);
          if (!resp.ok) { alert('Load failed'); return; }
          const j = await resp.json();
          if (j && j.state) {
            const s = j.state;
            setPiecesState(s.piecesState || []);
            setMoveHistory(s.moveHistory || []);
            setCurrentTurn(s.currentTurn || 'white');
            setLastMove(s.lastMove || null);
            try { setAiSide(s.aiSide || null); } catch (e) {}
            try { setGameStarted(!!s.gameStarted); } catch (e) {}
            // store id/token for future updates
            if (j.id && j.ownerToken) {
              localStorage.setItem(SERVER_ID_KEY, j.id);
              localStorage.setItem(SERVER_TOKEN_KEY, j.ownerToken);
            }
            alert('Loaded from server');
          }
        } catch (e) { alert('Server load failed'); }
      };

      // auto-load server save if present
      const suppressAutoSaveRef = useRef(false);
      useEffect(() => {
        (async () => {
          try {
            const id = localStorage.getItem(SERVER_ID_KEY);
            if (id) {
              suppressAutoSaveRef.current = true;
              await loadFromServer(id);
              // allow a short grace period before auto-saving again
              setTimeout(() => { suppressAutoSaveRef.current = false; }, 100);
            }
          } catch (e) {}
        })();
      }, []);

      // autosave to server after moves/pieces change (debounced)
      useEffect(() => {
        if (suppressAutoSaveRef.current) return;
        const timer = setTimeout(() => {
          try { saveToServer(); } catch (e) { console.debug('autosave failed', e); }
        }, 500);
        return () => clearTimeout(timer);
      }, [piecesState, moveHistory, currentTurn, lastMove, aiSide, gameStarted]);

      // AI player: when currentTurn matches aiSide, compute and play a move
      // Improved AI: minimax with alpha-beta, material + center control + mobility evaluation

      const minimax = useCallback((pieces, color, depth, alpha, beta, maximizing) => {
        // time cutoff
        try { if (searchStateRef.current && Date.now() > searchStateRef.current.endTime) return evaluatePosition(pieces, maximizing ? color : (color === 'white' ? 'black' : 'white')); } catch (e) {}
        // terminal checks
        const moves = getAllLegalMoves(pieces, color) || [];
        if (depth === 0 || moves.length === 0) {
          // if no moves, penalize if in check (mate) else neutral
          if (moves.length === 0) {
            const inCheck = isAnyKingInCheck(pieces, color);
            return inCheck ? (inCheck && maximizing ? -999999 : 999999) : evaluatePosition(pieces, maximizing ? color : (color === 'white' ? 'black' : 'white'));
          }
          // use quiescence search at leaf to resolve capture sequences
          try {
            return quiescenceSearch(pieces, color, alpha, beta, 4, maximizing);
          } catch (e) {
            return evaluatePosition(pieces, maximizing ? color : (color === 'white' ? 'black' : 'white'));
          }
        }
        const nextColor = color === 'white' ? 'black' : 'white';
        if (maximizing) {
          let value = -Infinity;
          const ordered = orderMoves(moves, pieces, color);
          for (const m of ordered) {
            try { if (searchStateRef.current && Date.now() > searchStateRef.current.endTime) return evaluatePosition(pieces, maximizing ? color : (color === 'white' ? 'black' : 'white')); } catch (e) {}
            const next = simulateMove(pieces, m.moverId, { x: m.x, y: m.y, z: m.z });
            const v = minimax(next, nextColor, depth - 1, alpha, beta, false);
            value = Math.max(value, v);
            alpha = Math.max(alpha, value);
            if (alpha >= beta) break;
          }
          return value;
        } else {
          let value = Infinity;
          const ordered = orderMoves(moves, pieces, color);
          for (const m of ordered) {
            try { if (searchStateRef.current && Date.now() > searchStateRef.current.endTime) return evaluatePosition(pieces, maximizing ? color : (color === 'white' ? 'black' : 'white')); } catch (e) {}
            const next = simulateMove(pieces, m.moverId, { x: m.x, y: m.y, z: m.z });
            const v = minimax(next, nextColor, depth - 1, alpha, beta, true);
            value = Math.min(value, v);
            beta = Math.min(beta, value);
            if (alpha >= beta) break;
          }
          return value;
        }
      }, [getAllLegalMoves, simulateMove, isAnyKingInCheck, evaluatePosition, orderMoves]);

      // Quiescence search: explore capture sequences so static eval isn't fooled by immediate captures
      const quiescenceSearch = useCallback((pieces, color, alpha, beta, depthLeft, maximizing) => {
        // stand-pat evaluation
        let standPat = evaluatePosition(pieces, maximizing ? color : (color === 'white' ? 'black' : 'white'));
        if (standPat >= beta) return beta;
        if (alpha < standPat) alpha = standPat;
        if (depthLeft <= 0) return standPat;
        // generate capture moves only
        let captures = [];
        try {
          const all = getAllLegalMoves(pieces, color) || [];
          for (const m of all) {
            const occ = (pieces || []).find(pp => pp.x === m.x && pp.y === m.y && pp.z === m.z && pp.color !== color);
            // include en-passant and explicit captures
            if (occ || (m.enPassant)) captures.push(m);
          }
        } catch (e) { captures = []; }
        // if no captures, return stand-pat
        if (!captures || captures.length === 0) return standPat;
        // order captures by victim value
        captures = orderMoves(captures, pieces, color);
        const nextColor = color === 'white' ? 'black' : 'white';
        if (maximizing) {
          let value = -Infinity;
          for (const m of captures) {
            try { if (searchStateRef.current && Date.now() > searchStateRef.current.endTime) return evaluatePosition(pieces, maximizing ? color : (color === 'white' ? 'black' : 'white')); } catch (e) {}
            const next = simulateMove(pieces, m.moverId, { x: m.x, y: m.y, z: m.z });
            const v = quiescenceSearch(next, nextColor, alpha, beta, depthLeft - 1, false);
            value = Math.max(value, v);
            alpha = Math.max(alpha, value);
            if (alpha >= beta) break;
          }
          return value;
        } else {
          let value = Infinity;
          for (const m of captures) {
            try { if (searchStateRef.current && Date.now() > searchStateRef.current.endTime) return evaluatePosition(pieces, maximizing ? color : (color === 'white' ? 'black' : 'white')); } catch (e) {}
            const next = simulateMove(pieces, m.moverId, { x: m.x, y: m.y, z: m.z });
            const v = quiescenceSearch(next, nextColor, alpha, beta, depthLeft - 1, true);
            value = Math.min(value, v);
            beta = Math.min(beta, value);
            if (alpha >= beta) break;
          }
          return value;
        }
      }, [getAllLegalMoves, orderMoves, simulateMove, evaluatePosition]);

      useEffect(() => {
        if (!aiSide) return;
        if (gameOver) return;
        if (currentTurn !== aiSide) return;
        const thinkDelay = 300 + Math.floor(Math.random() * 400);
        const t = setTimeout(() => {
          (async () => {
            try {
              let moves = getAllLegalMoves(piecesState, aiSide || 'black');
              // Hard-ban early non-castling king moves if castling is currently available
              try {
                const plyCount = (moveHistory || []).length || 0;
                // consider castling rights possible if king and at least one rook haven't moved (even if castling isn't legal right now)
                const kingPiece = (piecesState || []).find(p => p.color === aiSide && p.t === 'K');
                const rookExists = (piecesState || []).some(p => p.color === aiSide && p.t === 'R' && !p.hasMoved);
                const castleAvailable = kingPiece && !kingPiece.hasMoved && rookExists;
                if (castleAvailable && plyCount < 12) {
                  const nonKing = (moves || []).filter(m => {
                    try {
                      const pm = (piecesState || []).find(p => p.id === m.moverId) || null;
                      if (!pm) return true;
                      // allow castling moves, disallow other king moves
                      if (pm.t === 'K' && !(m && m.castle)) return false;
                      return true;
                    } catch (e) { return true; }
                  });
                  if (nonKing.length > 0) {
                    try { console.debug('AI filtered out early non-castling king moves to preserve castling', { before: moves.length, after: nonKing.length }); } catch (e) {}
                    moves = nonKing;
                  }
                }
              } catch (e) {}
              if (!moves || moves.length === 0) return;

              // Opening book reply (best-effort, safe-guarded)
              try {
                const openingMap = {
                  '3c4': '3c5', '3b4': '3b5', '2b4': '2b5', '2c4': '2c5', '2a4': '2c5', '2d4': '2b5',
                  '3a4': '3c5', '3d4': '3b5', 'N1c3': '2c5', 'N2b3': '2c5', 'N2c3': '2c5', 'N3d3': '2b5',
                  'N4b3': '3b5', 'N3c3': '3b5'
                };
                const parseNotation = (s) => {
                  if (!s || typeof s !== 'string') return null;
                  const m = s.match(/^([1-4])([a-d])([1-8])$/);
                  if (!m) return null;
                  const z = Number(m[1]) - 1;
                  const y = m[2].charCodeAt(0) - 'a'.charCodeAt(0);
                  const x = 8 - Number(m[3]);
                  return { x, y, z };
                };
                const lastEntry = (moveHistory && moveHistory.length) ? moveHistory[moveHistory.length - 1] : null;
                if (lastEntry && moveHistory.length == 1) {
                  const lastNotationRaw = (aiSide === 'black') ? lastEntry.white : lastEntry.black;
                  let lastNotation = lastNotationRaw;
                  try { if (lastNotation) lastNotation = lastNotation.replace(/\([^\)]*\)/g, '').replace(/x/g, '').trim(); } catch (e) {}
                  if (lastNotation) {
                    let matched = null; let reply = null; let usedMirror = false;
                    if (openingMap[lastNotation]) { matched = lastNotation; reply = openingMap[lastNotation]; }
                    else {
                      try {
                        const mm = (lastNotation || '').match(/^([NBRQK]?)([1-4][a-d][1-8])$/i);
                        if (mm) {
                          const prefix = mm[1] || '';
                          const core = mm[2];
                          const parsed = parseNotation(core);
                          if (parsed) {
                            const mirrored = { x: 7 - parsed.x, y: parsed.y, z: parsed.z };
                            const mirroredKey = prefix + (mirrored.z + 1) + String.fromCharCode('a'.charCodeAt(0) + mirrored.y) + (8 - mirrored.x);
                            if (openingMap[mirroredKey]) { matched = mirroredKey; reply = openingMap[mirroredKey]; usedMirror = true; }
                          }
                        }
                      } catch (e) {}
                    }
                    // if nothing matched and this is Black's first automatic reply, default to 3c5
                    try {
                      if (!matched && aiSide === 'black' && (!moveHistory || moveHistory.length === 1)) {
                        matched = '3c5'; reply = '3c5'; usedMirror = false;
                      }
                    } catch (e) {}

                    if (matched && reply) {
                      let coord = parseNotation(reply);
                      if (coord) {
                        if (usedMirror) coord = { x: 7 - coord.x, y: coord.y, z: coord.z };
                      }
                      const candidate = moves.find(m => m.x === coord.x && m.y === coord.y && m.z === coord.z);
                      if (candidate) {
                        try {
                          const nextTmp = simulateMove(piecesState, candidate.moverId, { x: candidate.x, y: candidate.y, z: candidate.z });
                          const opp = aiSide === 'white' ? 'black' : 'white';
                          const oppMovesTmp = getAllLegalMoves(nextTmp, opp) || [];
                          let unsafe = false;
                          for (const oc of oppMovesTmp) {
                            const targetOcc = nextTmp.find(pp => pp.x === oc.x && pp.y === oc.y && pp.z === oc.z && pp.color === aiSide);
                            if (!targetOcc) continue;
                            try { if (staticExchangeEval(nextTmp, oc.x, oc.y, oc.z, opp) > 0) { unsafe = true; break; } } catch (e) {}
                          }
                          try { console.debug('AI opening book reply playing', { reply, candidate, unsafe }); } catch (e) {}
                          applyMove(candidate.moverId, { x: candidate.x, y: candidate.y, z: candidate.z });
                          return;
                        } catch (e) { /* skip book reply on any error */ }
                      }
                    }
                  }
                }
              } catch (e) {}

              // iterative deepening search with safety heuristics
              const maxMillis = 800;
              searchStateRef.current.endTime = Date.now() + maxMillis;
              const maxDepth = 4;
              let best = null; let bestScore = -Infinity;
              let orderedMoves = orderMoves(moves, piecesState, aiSide);
              // Diagnostic: snapshot ordered moves with basic SEE/attackers info for each candidate
              try {
                const opponent = aiSide === 'white' ? 'black' : 'white';
                const snap = [];
                for (const m of orderedMoves) {
                  try {
                    const mover = (piecesState || []).find(p => p.id === m.moverId) || null;
                    const next = simulateMove(piecesState, m.moverId, { x: m.x, y: m.y, z: m.z });
                    const attackers = attackersOfSquare(next, m.x, m.y, m.z).filter(a => a.color !== aiSide).length;
                    const defenders = attackersOfSquare(next, m.x, m.y, m.z).filter(a => a.color === aiSide).length;
                    const oppMoves = getAllLegalMoves(next, opponent) || [];
                    const captures = oppMoves.filter(oc => oc.x === m.x && oc.y === m.y && oc.z === m.z);
                    let bestSee = null;
                    for (const oc of captures) {
                      try { const s = staticExchangeEval(next, oc.x, oc.y, oc.z, opponent); if (typeof s === 'number' && (bestSee == null || s > bestSee)) bestSee = s; } catch (e) { bestSee = 'ERR'; }
                    }
                    snap.push({ moverId: m.moverId, type: mover ? mover.t : '?', from: {x: mover ? mover.x : null, y: mover ? mover.y : null, z: mover ? mover.z : null}, to: {x: m.x,y: m.y,z: m.z}, attackers, defenders, bestSee });
                  } catch (e) { snap.push({ moverId: m.moverId, to: {x: m.x,y: m.y,z: m.z}, err: true }); }
                }
                try { pushDebug('orderedMovesSnapshot', { snap, moveHistoryLen: (moveHistory||[]).length }); } catch (e) {}
                try { console.log('orderedMovesSnapshot', snap); } catch (e) {}
              } catch (e) {}

              // Strict immediate-loss veto: remove any move that allows an immediate positive-SEE capture
              try {
                const vals = { p: 1, N: 3, B: 3, R: 5, Q: 9, K: 10000 };
                const opponent = aiSide === 'white' ? 'black' : 'white';
                const filtered = [];
                for (const m of orderedMoves) {
                  try {
                    const targetBefore = (piecesState || []).find(pp => pp.x === m.x && pp.y === m.y && pp.z === m.z && pp.color !== aiSide) || null;
                    const n = simulateMove(piecesState, m.moverId, { x: m.x, y: m.y, z: m.z });
                    // is opponent able to capture moved square with positive SEE?
                    const oppMoves = getAllLegalMoves(n, opponent) || [];
                    let maxSee = 0; let canCapture = false;
                    for (const oc of oppMoves) {
                      if (oc.x === m.x && oc.y === m.y && oc.z === m.z) {
                        try { const s = staticExchangeEval(n, oc.x, oc.y, oc.z, opponent); if (typeof s === 'number' && s > maxSee) maxSee = s; canCapture = true; } catch (e) { canCapture = true; maxSee = Math.max(maxSee, 0); }
                      }
                    }
                    const attackers = attackersOfSquare(n, m.x, m.y, m.z).filter(a => a.color !== aiSide).length;
                    const defenders = attackersOfSquare(n, m.x, m.y, m.z).filter(a => a.color === aiSide).length;
                    let veto = false;
                    if (canCapture && maxSee > 0 && attackers > defenders) {
                      // allow if moved piece captures a higher-value piece than the opponent's gain
                      if (targetBefore && (vals[targetBefore.t] || 0) > maxSee) {
                        veto = false;
                      } else {
                        // allow if this move gives mate to opponent (rare) -- detect: opponent has no legal moves and is in check after their capture? skip veto if mate-in-1 for opponent? conservatively veto
                        veto = true;
                      }
                    }
                    if (!veto) filtered.push(m);
                    else { try { console.debug('AI immediate-loss veto removed move', { move: m, maxSee, attackers, defenders, captured: targetBefore && targetBefore.t }); } catch (e) {} }
                  } catch (e) { filtered.push(m); }
                }
                if (filtered.length > 0) orderedMoves = filtered;
              } catch (e) {}

              // Strong defender-priority: if any Queen/Rook/Knight/Bishop is attacked and can be safely retreated/defended, prioritize those moves
              try {
                const highVals = ['Q','R','N','B'];
                const threatenedPieces = (piecesState || []).filter(p => p.color === aiSide && highVals.includes(p.t) && attackersOfSquare(piecesState, p.x, p.y, p.z).filter(a => a.color !== aiSide).length > 0);
                if (threatenedPieces.length > 0) {
                  const rescueMoves = [];
                  for (const tp of threatenedPieces) {
                    try {
                      const myMoves = (getAllLegalMoves(piecesState, aiSide) || []).filter(m => m.moverId === tp.id);
                      for (const mm of myMoves) {
                        try {
                          const n = simulateMove(piecesState, mm.moverId, { x: mm.x, y: mm.y, z: mm.z });
                          const opponent = aiSide === 'white' ? 'black' : 'white';
                          const oppMoves = getAllLegalMoves(n, opponent) || [];
                          let canBeCaptured = false; let maxSee = 0;
                          for (const oc of oppMoves) {
                            if (oc.x === mm.x && oc.y === mm.y && oc.z === mm.z) {
                              try { const s = staticExchangeEval(n, oc.x, oc.y, oc.z, opponent); if (typeof s === 'number') { maxSee = Math.max(maxSee, s); if (s > 0) canBeCaptured = true; } else { canBeCaptured = true; } } catch (e) { canBeCaptured = true; }
                            }
                          }
                          const attackers = attackersOfSquare(n, mm.x, mm.y, mm.z).filter(a => a.color !== aiSide).length;
                          const defenders = attackersOfSquare(n, mm.x, mm.y, mm.z).filter(a => a.color === aiSide).length;
                          // consider this a valid rescue if it eliminates positive-SEE capture and defenders >= attackers
                          if (!canBeCaptured || defenders >= attackers) {
                            rescueMoves.push(mm);
                          }
                        } catch (e) {}
                      }
                    } catch (e) {}
                  }
                  if (rescueMoves.length > 0) {
                    try { console.debug('AI defender-priority: prioritizing rescue moves', { rescueCount: rescueMoves.length, threatened: threatenedPieces.map(p=>p.id) }); } catch (e) {}
                    // move rescues to the front preserving order
                    orderedMoves = rescueMoves.concat(orderedMoves.filter(m => !rescueMoves.find(r => r.moverId === m.moverId && r.x === m.x && r.y === m.y && r.z === m.z)));
                  }
                }
              } catch (e) {}

              // Mate-threat filter: prefer moves that prevent opponent mate-in-1
              try {
                const opponent = aiSide === 'white' ? 'black' : 'white';
                const evasive = [];
                for (const m of orderedMoves) {
                  try {
                    const next = simulateMove(piecesState, m.moverId, { x: m.x, y: m.y, z: m.z });
                    const oppMoves = getAllLegalMoves(next, opponent) || [];
                    let leavesMate = false;
                    for (const om of oppMoves) {
                      try {
                        const next2 = simulateMove(next, om.moverId, { x: om.x, y: om.y, z: om.z });
                        const inCheck = isAnyKingInCheck(next2, aiSide);
                        const myLegal = (getAllLegalMoves(next2, aiSide) || []);
                        if (inCheck && myLegal.length === 0) { leavesMate = true; break; }
                      } catch (e) { /* ignore simulation errors */ }
                    }
                    if (!leavesMate) evasive.push(m);
                  } catch (e) { /* ignore per-move errors */ }
                }
                if (evasive.length > 0) {
                  try { console.debug('AI mate-threat filter applied, reducing moves', { before: orderedMoves.length, after: evasive.length }); } catch (e) {}
                  orderedMoves = evasive;
                }
              } catch (e) { /* fail-safe: ignore mate filter on error */ }

              // High-value piece safety filter: prefer moves that address immediate threats to Q/R
              try {
                const highVals = ['Q','R'];
                const opponent = aiSide === 'white' ? 'black' : 'white';
                const threatened = [];
                for (const p of (piecesState || [])) {
                  if (p.color !== aiSide) continue;
                  if (!highVals.includes(p.t)) continue;
                  try {
                    const attackers = attackersOfSquare(piecesState, p.x, p.y, p.z).filter(a => a.color !== aiSide).length;
                    const defenders = attackersOfSquare(piecesState, p.x, p.y, p.z).filter(a => a.color === aiSide).length;
                    if (attackers > defenders) threatened.push(p);
                    else {
                      try { const seeNow = staticExchangeEval(piecesState, p.x, p.y, p.z, opponent); if (typeof seeNow === 'number' && seeNow > 0) threatened.push(p); } catch (e) {}
                    }
                  } catch (e) {}
                }
                if (threatened.length > 0) {
                  const defendersMoves = [];
                  for (const m of orderedMoves) {
                    try {
                      const next = simulateMove(piecesState, m.moverId, { x: m.x, y: m.y, z: m.z });
                      let addresses = false;
                      for (const tp of threatened) {
                        try {
                          // find the piece in the new position (it may have moved)
                          const myPiece = next.find(pp => pp.id === tp.id) || null;
                          const tx = myPiece ? myPiece.x : tp.x;
                          const ty = myPiece ? myPiece.y : tp.y;
                          const tz = myPiece ? myPiece.z : tp.z;
                          const attackers = attackersOfSquare(next, tx, ty, tz).filter(a => a.color !== aiSide).length;
                          const defenders = attackersOfSquare(next, tx, ty, tz).filter(a => a.color === aiSide).length;
                          if (defenders >= attackers) { addresses = true; break; }
                          // also allow moves that capture an attacker
                          const attackedBy = attackersOfSquare(next, tx, ty, tz).filter(a => a.color !== aiSide);
                          for (const at of attackedBy) {
                            if (next.find(pp => pp.id === m.moverId && pp.x === at.x && pp.y === at.y && pp.z === at.z)) { addresses = true; break; }
                          }
                        } catch (e) {}
                      }
                      if (addresses) defendersMoves.push(m);
                    } catch (e) {}
                  }
                  if (defendersMoves.length > 0) {
                    try { console.debug('AI high-value safety filter applied', { threatenedCount: threatened.length, before: orderedMoves.length, after: defendersMoves.length }); } catch (e) {}
                    orderedMoves = defendersMoves;
                  }
                }
              } catch (e) { /* ignore safety filter failures */ }

              // Diagnostic: log detailed info for pawn moves that are capturable next turn
              try {
                const opponent = aiSide === 'white' ? 'black' : 'white';
                for (const m of orderedMoves) {
                  try {
                    const mover = (piecesState || []).find(p => p.id === m.moverId);
                    if (!mover || mover.t !== 'p') continue;
                    const next = simulateMove(piecesState, m.moverId, { x: m.x, y: m.y, z: m.z });
                    const oppMoves = getAllLegalMoves(next, opponent) || [];
                    const captures = oppMoves.filter(oc => oc.x === m.x && oc.y === m.y && oc.z === m.z);
                    if (captures.length === 0) continue;
                    const capDetails = [];
                    for (const oc of captures) {
                      try {
                        const see = staticExchangeEval(next, oc.x, oc.y, oc.z, opponent);
                        const capPiece = next.find(pp => pp.x === oc.x && pp.y === oc.y && pp.z === oc.z && pp.color === aiSide) || null;
                        capDetails.push({ by: oc.moverId, moverType: (next.find(pp=>pp.id===oc.moverId)||{}).t || '?', see, capPieceType: capPiece ? capPiece.t : null });
                      } catch (e) { capDetails.push({ by: oc.moverId, moverType: (next.find(pp=>pp.id===oc.moverId)||{}).t || '?', see: 'ERR' }); }
                    }
                    const attackers = attackersOfSquare(next, m.x, m.y, m.z).filter(a => a.color !== aiSide).length;
                    const defenders = attackersOfSquare(next, m.x, m.y, m.z).filter(a => a.color === aiSide).length;
                    try { pushDebug('pawnDiagnostic', { moverId: mover.id, from: {x:mover.x,y:mover.y,z:mover.z}, to: {x:m.x,y:m.y,z:m.z}, captures: capDetails, attackers, defenders, moveHistoryLen: (moveHistory||[]).length }); } catch (e) {}
                    try { console.log('pawnDiagnostic', { moverId: mover.id, from: {x:mover.x,y:mover.y,z:mover.z}, to: {x:m.x,y:m.y,z:m.z}, captures: capDetails, attackers, defenders }); } catch (e) {}
                  } catch (e) {}
                }
              } catch (e) {}

              // Pawn-safety filter: avoid pawn moves that immediately lose material
              try {
                const pawnSafe = [];
                const opponent = aiSide === 'white' ? 'black' : 'white';
                for (const m of orderedMoves) {
                  try {
                    const mover = (piecesState || []).find(p => p.id === m.moverId);
                    if (!mover || mover.t !== 'p') { pawnSafe.push(m); continue; }
                    const next = simulateMove(piecesState, m.moverId, { x: m.x, y: m.y, z: m.z });
                    const oppMoves = getAllLegalMoves(next, opponent) || [];
                    let donation = false;
                    for (const oc of oppMoves) {
                      if (oc.x === m.x && oc.y === m.y && oc.z === m.z) {
                        try {
                          const see = staticExchangeEval(next, oc.x, oc.y, oc.z, opponent);
                          const attackers = attackersOfSquare(next, m.x, m.y, m.z).filter(a => a.color !== aiSide).length;
                          const defenders = attackersOfSquare(next, m.x, m.y, m.z).filter(a => a.color === aiSide).length;
                          if ((typeof see === 'number' && see > 0) || attackers > defenders) { donation = true; break; }
                        } catch (e) { /* ignore */ }
                      }
                    }
                    if (!donation) pawnSafe.push(m);
                  } catch (e) { pawnSafe.push(m); }
                }
                if (pawnSafe.length > 0 && pawnSafe.length < orderedMoves.length) {
                  try { console.debug('AI pawn-safety filter applied', { before: orderedMoves.length, after: pawnSafe.length }); } catch (e) {}
                  orderedMoves = pawnSafe;
                }
              } catch (e) { /* ignore pawn filter failures */ }

              // quick immediate capture scan (all moves) but respect immediate-loss veto
              try {
                const vals = { p: 1, N: 3, B: 3, R: 5, Q: 9, K: 10000 };
                const captureMoves = (moves || []).filter(m => (piecesState || []).some(pp => pp.x === m.x && pp.y === m.y && pp.z === m.z && pp.color !== aiSide));
                if (captureMoves.length > 0) {
                  let bestCap = null; let bestSee = -Infinity;
                  for (const m of captureMoves) {
                    try {
                      const see = staticExchangeEval(piecesState, m.x, m.y, m.z, aiSide);
                      // simulate and ensure this capture isn't immediately punished by opponent (veto)
                      const nextTmp = simulateMove(piecesState, m.moverId, { x: m.x, y: m.y, z: m.z });
                      const opp = aiSide === 'white' ? 'black' : 'white';
                      const oppMovesTmp = getAllLegalMoves(nextTmp, opp) || [];
                      let maxOppSee = 0; let oppCanCapture = false;
                      for (const oc of oppMovesTmp) {
                        if (oc.x === m.x && oc.y === m.y && oc.z === m.z) {
                          try { const s = staticExchangeEval(nextTmp, oc.x, oc.y, oc.z, opp); if (typeof s === 'number' && s > maxOppSee) maxOppSee = s; oppCanCapture = true; } catch (e) { oppCanCapture = true; maxOppSee = Math.max(maxOppSee, 0); }
                        }
                      }
                      const attackers = attackersOfSquare(nextTmp, m.x, m.y, m.z).filter(a => a.color !== aiSide).length;
                      const defenders = attackersOfSquare(nextTmp, m.x, m.y, m.z).filter(a => a.color === aiSide).length;
                      const capturedPiece = (piecesState || []).find(pp => pp.x === m.x && pp.y === m.y && pp.z === m.z && pp.color !== aiSide) || null;
                      const capturedVal = capturedPiece ? (vals[capturedPiece.t] || 0) : 0;
                      // veto capture if opponent can immediately gain material and attackers outnumber defenders, unless we captured a strictly higher-value piece
                      const veto = oppCanCapture && maxOppSee > 0 && attackers > defenders && !(capturedVal > maxOppSee);
                      if (!veto) {
                        if (typeof see === 'number' && see > bestSee) { bestSee = see; bestCap = m; }
                      } else {
                        try { console.debug('AI capture-scan vetoed unsafe capture', { move: m, maxOppSee, attackers, defenders, captured: capturedPiece && capturedPiece.t }); } catch (e) {}
                      }
                    } catch (e) {}
                  }
                  if (bestCap && (bestSee >= 1 || ((piecesState || []).find(pp=>pp.x===bestCap.x && pp.y===bestCap.y && pp.z===bestCap.z && pp.color!==aiSide) || {}).t === 'R' || ((piecesState || []).find(pp=>pp.x===bestCap.x && pp.y===bestCap.y && pp.z===bestCap.z && pp.color!==aiSide) || {}).t === 'Q')) {
                    try { applyMove(bestCap.moverId, { x: bestCap.x, y: bestCap.y, z: bestCap.z }); } catch (e) {}
                    return;
                  }
                }
              } catch (e) {}

              // search iterations
              for (let depth = 1; depth <= maxDepth; depth++) {
                if (Date.now() > searchStateRef.current.endTime) break;
                let localBest = null; let localBestScore = -Infinity;
                for (const m of orderedMoves) {
                  if (Date.now() > searchStateRef.current.endTime) break;
                  try {
                    const next = simulateMove(piecesState, m.moverId, { x: m.x, y: m.y, z: m.z });
                    // Skip moves that immediately allow the opponent to capture the moved piece for net material gain
                    try {
                      const opp = aiSide === 'white' ? 'black' : 'white';
                      const oppMovesQuick = getAllLegalMoves(next, opp) || [];
                      let immediateLoss = false;
                      for (const oc of oppMovesQuick) {
                        if (oc.x === m.x && oc.y === m.y && oc.z === m.z) {
                          try {
                            const seeLoss = staticExchangeEval(next, oc.x, oc.y, oc.z, opp);
                            if (typeof seeLoss === 'number' && seeLoss > 0) { immediateLoss = true; break; }
                          } catch (e) { immediateLoss = true; break; }
                        }
                      }
                      if (immediateLoss) {
                        // allow if move gives immediate mate to opponent? already false since opponent capturing is mate-irrelevant
                        continue;
                      }
                    } catch (e) {}
                    const opp = aiSide === 'white' ? 'black' : 'white';
                    const oppMoves = getAllLegalMoves(next, opp) || [];
                    if (oppMoves.length === 0 && isAnyKingInCheck(next, opp)) { localBest = m; localBestScore = Infinity; break; }
                    let score = minimax(next, opp, depth - 1, -Infinity, Infinity, false);
                    let finalScore = score + Math.random() * 1e-6;
                    // penalize immediate SEE losses: compute max immediate capture gain opponent can get on the moved square
                    try {
                      const oppMoves2 = getAllLegalMoves(next, opp) || [];
                      let maxImmediateSee = 0;
                      let attackers = 0;
                      let defenders = 0;
                      for (const oc of oppMoves2) {
                        const targetOcc = next.find(pp => pp.x === oc.x && pp.y === oc.y && pp.z === oc.z && pp.color === aiSide);
                        if (!targetOcc) continue;
                        try {
                          const s = staticExchangeEval(next, oc.x, oc.y, oc.z, opp);
                          if (typeof s === 'number' && s > maxImmediateSee) maxImmediateSee = s;
                        } catch (e) { maxImmediateSee = Math.max(maxImmediateSee, 0); }
                      }
                      attackers = attackersOfSquare(next, m.x, m.y, m.z).filter(a => a.color !== aiSide).length;
                      defenders = attackersOfSquare(next, m.x, m.y, m.z).filter(a => a.color === aiSide).length;
                      if (maxImmediateSee > 0) {
                        finalScore -= maxImmediateSee * 2000; // strong penalty so search avoids obvious losing captures
                      }
                      if (attackers > defenders) {
                        finalScore -= (attackers - defenders) * 800; // penalize undefended moves
                      }
                    } catch (e) {}
                    if (finalScore > localBestScore) { localBestScore = finalScore; localBest = m; }
                  } catch (e) {}
                }
                if (localBest) { best = localBest; bestScore = localBestScore; orderedMoves = [best].concat(orderedMoves.filter(m => m !== best)); }
              }

              // final safety: avoid moves where moved piece is immediately captured with positive SEE if alternatives exist
              try {
                if (best) {
                  const next = simulateMove(piecesState, best.moverId, { x: best.x, y: best.y, z: best.z });
                  const opponent = aiSide === 'white' ? 'black' : 'white';
                  const oppMoves = getAllLegalMoves(next, opponent) || [];
                  let immediateBad = false;
                  for (const oc of oppMoves) {
                    if (oc.x === best.x && oc.y === best.y && oc.z === best.z) {
                      try {
                        const seeVal = staticExchangeEval(next, oc.x, oc.y, oc.z, opponent);
                        const attackers = attackersOfSquare(next, best.x, best.y, best.z).filter(a => a.color !== aiSide).length;
                        const defenders = attackersOfSquare(next, best.x, best.y, best.z).filter(a => a.color === aiSide).length;
                        // treat as immediate bad if SEE > 0 or attackers outnumber defenders (undefended)
                        if ((typeof seeVal === 'number' && seeVal > 0) || (attackers > defenders)) { immediateBad = true; break; }
                      } catch (e) {}
                    }
                  }
                  if (immediateBad) {
                    // try to find any ordered alternative that is not immediately badly captured
                    for (const cand of orderedMoves) {
                      if (cand === best) continue;
                      try {
                        const n2 = simulateMove(piecesState, cand.moverId, { x: cand.x, y: cand.y, z: cand.z });
                        const opp2 = getAllLegalMoves(n2, opponent) || [];
                        let bad2 = false;
                        for (const oc of opp2) {
                          if (oc.x === cand.x && oc.y === cand.y && oc.z === cand.z) {
                            try {
                              const s2 = staticExchangeEval(n2, oc.x, oc.y, oc.z, opponent);
                              const attackers2 = attackersOfSquare(n2, cand.x, cand.y, cand.z).filter(a => a.color !== aiSide).length;
                              const defenders2 = attackersOfSquare(n2, cand.x, cand.y, cand.z).filter(a => a.color === aiSide).length;
                              if ((typeof s2 === 'number' && s2 > 0) || (attackers2 > defenders2)) { bad2 = true; break; }
                            } catch (e) { bad2 = true; break; }
                          }
                        }
                        if (!bad2) { try { console.debug('AI switched from immediate-bad best to safer candidate', { from: best, to: cand }); } catch (e) {} best = cand; break; }
                      } catch (e) {}
                    }
                  }
                }
              } catch (e) {}

                // apply final move
              try {
                if (!best) best = moves[Math.floor(Math.random() * moves.length)];
                // Safety selection: prefer candidate with minimal opponent immediate capture SEE
                try {
                  const opponent = aiSide === 'white' ? 'black' : 'white';
                  let candidates = orderedMoves.slice();
                  if (!candidates || candidates.length === 0) candidates = [best];
                  let safest = null; let safestSee = Infinity; let safestIsPawn = true;
                  for (const cand of candidates) {
                    try {
                      const n = simulateMove(piecesState, cand.moverId, { x: cand.x, y: cand.y, z: cand.z });
                      const oppMoves = getAllLegalMoves(n, opponent) || [];
                      let maxSee = -Infinity;
                      for (const oc of oppMoves) {
                        if (oc.x === cand.x && oc.y === cand.y && oc.z === cand.z) {
                          try { const s = staticExchangeEval(n, oc.x, oc.y, oc.z, opponent); if (typeof s === 'number' && s > maxSee) maxSee = s; } catch (e) { maxSee = Math.max(maxSee, 0); }
                        }
                      }
                      if (maxSee < safestSee || (maxSee === safestSee && ((piecesState||[]).find(p=>p.id===cand.moverId)||{}).t !== 'p' && safestIsPawn)) {
                        safest = cand; safestSee = (maxSee === -Infinity ? 0 : maxSee);
                        safestIsPawn = (((piecesState||[]).find(p=>p.id===cand.moverId)||{}).t === 'p');
                      }
                    } catch (e) {}
                  }
                  if (safest) {
                    try { console.debug('AI safety selection chose', { from: best, to: safest, safestSee }); } catch (e) {}
                    best = safest;
                  }
                } catch (e) {}
                // Detailed debug: log why this final move is chosen, especially for pawns
                try {
                  const moverPiece = (piecesState || []).find(p => p.id === best.moverId) || null;
                  const opponent = aiSide === 'white' ? 'black' : 'white';
                  const next = simulateMove(piecesState, best.moverId, { x: best.x, y: best.y, z: best.z });
                  const oppMoves = getAllLegalMoves(next, opponent) || [];
                  const captures = oppMoves.filter(oc => oc.x === best.x && oc.y === best.y && oc.z === best.z).map(oc => {
                    try { return { moverId: oc.moverId, type: (next.find(pp=>pp.id===oc.moverId)||{}).t || '?', see: staticExchangeEval(next, oc.x, oc.y, oc.z, opponent) }; } catch (e) { return { moverId: oc.moverId, type: (next.find(pp=>pp.id===oc.moverId)||{}).t || '?', see: 'ERR' }; }
                  });
                  const attackers = attackersOfSquare(next, best.x, best.y, best.z).filter(a => a.color !== aiSide).length;
                  const defenders = attackersOfSquare(next, best.x, best.y, best.z).filter(a => a.color === aiSide).length;
                  try { pushDebug('finalMoveDecision', { best, moverPieceType: moverPiece ? moverPiece.t : null, captures, attackers, defenders, moveHistoryLen: (moveHistory||[]).length }); } catch (e) {}
                  try { console.log('finalMoveDecision', { best, moverPieceType: moverPiece ? moverPiece.t : null, captures, attackers, defenders }); } catch (e) {}
                } catch (e) {}
                // Extra king-safety veto: avoid moving king into as-many-or-more attacked square
                try {
                  const moverPieceFinal = (piecesState || []).find(p => p.id === best.moverId) || null;
                  if (moverPieceFinal && moverPieceFinal.t === 'K') {
                    try {
                      const kingBefore = moverPieceFinal;
                      const attackersBefore = attackersOfSquare(piecesState, kingBefore.x, kingBefore.y, kingBefore.z).filter(a => a.color !== aiSide).length;
                      const nextBest = simulateMove(piecesState, best.moverId, { x: best.x, y: best.y, z: best.z });
                      const attackersAfter = attackersOfSquare(nextBest, best.x, best.y, best.z).filter(a => a.color !== aiSide).length;
                      if (attackersAfter > 0 && attackersAfter >= attackersBefore) {
                        // try to find a non-king alternative that improves king safety
                        let alternative = null;
                        for (const cand of orderedMoves) {
                          try {
                            const moverCand = (piecesState || []).find(p => p.id === cand.moverId) || null;
                            if (moverCand && moverCand.t === 'K') continue;
                            const nCand = simulateMove(piecesState, cand.moverId, { x: cand.x, y: cand.y, z: cand.z });
                            const attackersCand = attackersOfSquare(nCand, cand.x, cand.y, cand.z).filter(a => a.color !== aiSide).length;
                            if (attackersCand < attackersBefore) { alternative = cand; break; }
                          } catch (e) { /* ignore candidate errors */ }
                        }
                        if (alternative) {
                          try { console.debug('AI avoided unsafe king move, switching to alternative', { from: best, to: alternative, attackersBefore, attackersAfter }); } catch (e) {}
                          best = alternative;
                        } else {
                          try { console.debug('AI allowed king move despite safety check', { best, attackersBefore, attackersAfter }); } catch (e) {}
                        }
                      }
                    } catch (e) {}
                  }
                } catch (e) {}
                // Preserve castling rights: avoid early non-castling king moves when castling is available
                try {
                  const moverPieceFinal = (piecesState || []).find(p => p.id === best.moverId) || null;
                  if (moverPieceFinal && moverPieceFinal.t === 'K' && !(best && best.castle)) {
                    try {
                      const plyCount = (moveHistory || []).length || 0;
                        // consider castling rights possible if king and at least one rook haven't moved (even if castling isn't legal right now)
                        const kingPiece = (piecesState || []).find(p => p.color === aiSide && p.t === 'K');
                        const rookExists = (piecesState || []).some(p => p.color === aiSide && p.t === 'R' && !p.hasMoved);
                        const castleAvailable = kingPiece && !kingPiece.hasMoved && rookExists;
                      // if castling is available and early in the game, prefer non-king moves
                      if (castleAvailable && plyCount < 12) {
                        let alternative = null;
                        for (const cand of orderedMoves) {
                          try {
                            const moverCand = (piecesState || []).find(p => p.id === cand.moverId) || null;
                            if (!moverCand) continue;
                            if (moverCand.t === 'K') continue;
                            // prefer move that doesn't worsen king safety
                            const nCand = simulateMove(piecesState, cand.moverId, { x: cand.x, y: cand.y, z: cand.z });
                            const kingPos = moverPieceFinal;
                            const attackersBefore = attackersOfSquare(piecesState, kingPos.x, kingPos.y, kingPos.z).filter(a => a.color !== aiSide).length;
                            const attackersAfter = attackersOfSquare(nCand, kingPos.x, kingPos.y, kingPos.z).filter(a => a.color !== aiSide).length;
                            if (attackersAfter <= attackersBefore) { alternative = cand; break; }
                          } catch (e) { /* ignore candidate errors */ }
                        }
                        if (alternative) {
                          try { console.debug('AI avoided early king move to preserve castling, switching to alternative', { from: best, to: alternative }); } catch (e) {}
                          best = alternative;
                        } else {
                          try { console.debug('No suitable alternative found to preserve castling; allowing king move', { best }); } catch (e) {}
                        }
                      }
                    } catch (e) {}
                  }
                } catch (e) {}
                applyMove(best.moverId, { x: best.x, y: best.y, z: best.z });
                try { console.debug('AI applied move', best); } catch (e) {}
              } catch (e) { try { console.debug('AI applyMove failed', e); } catch (ee) {} }

            } catch (e) { try { console.debug('AI move failed', e); } catch (ee) {} }
          })();
        }, thinkDelay);
        return () => clearTimeout(t);
      }, [currentTurn, aiSide, piecesState, gameOver, getAllLegalMoves, simulateMove, minimax, applyMove, generateMoveNotation, orderMoves]);

      // keep OrbitControls enabled state in sync with pointer interaction/dragging
      useEffect(() => {
        try {
          if (controlsRef.current) {
            controlsRef.current.enabled = !pointerActive && !isDragging;
          }
        } catch (e) {}
      }, [pointerActive, isDragging, controlsRef]);

      // handle browser resize: update camera aspect and controls so canvas reflows correctly
      useEffect(() => {
        const onResize = () => {
          try {
            const canvas = document.querySelector('canvas');
            if (!canvas) return;
            const rect = canvas.getBoundingClientRect();
            // update camera aspect if available
            try {
              const cam = controlsRef && controlsRef.current && controlsRef.current.object;
              if (cam && typeof cam.aspect === 'number') {
                const w = Math.max(1, rect.width);
                const h = Math.max(1, rect.height);
                cam.aspect = w / h;
                if (typeof cam.updateProjectionMatrix === 'function') cam.updateProjectionMatrix();
                // reapply saved camera position/target to avoid visual shift
                try {
                  if (Array.isArray(camPos) && camPos.length === 3) {
                    cam.position.set(camPos[0], camPos[1], camPos[2]);
                  }
                  const c = controlsRef && controlsRef.current;
                  if (c && c.target && Array.isArray(camTarget) && camTarget.length === 3) {
                    c.target.set(camTarget[0], camTarget[1], camTarget[2]);
                  }
                } catch (e) {}
              }
            } catch (e) {}
            // force controls update and dispatch a single resize event
            try { if (controlsRef && controlsRef.current && typeof controlsRef.current.update === 'function') controlsRef.current.update(); } catch (e) {}
            try { window.dispatchEvent(new Event('chess3d:resize')); } catch (e) {}
          } catch (e) {}
        };
        window.addEventListener('resize', onResize);
        // call once shortly after mount to settle layout
        setTimeout(onResize, 100);
        return () => window.removeEventListener('resize', onResize);
      }, [controlsRef, camPos, camTarget]);



      return (
        <>
        <div className="layout">
                <aside className="sidebar">
            <h2 className="title">Quadlevel 3D Chess</h2>
            <div className="menu">
              {!gameStarted ? (
                <>
                  <button className="menu-button" onClick={() => { resetGame(); setAiSide(null); setGameStarted(true); }}>
                    Play 2-Player
                  </button>
                  <button className="menu-button" onClick={() => { resetGame(); setAiSide('white'); setGameStarted(true); }}>
                    Play AI White
                  </button>
                  <button className="menu-button" onClick={() => { resetGame(); setAiSide('black'); setGameStarted(true); }}>
                    Play AI Black
                  </button>
                </>
              ) : (
                <>
                <button className="menu-button" onClick={() => { resetGame(); setAiSide(null); setGameStarted(false); }}>
                  Start a new game
                </button>
              <hr />
              <button className="menu-button" onClick={exportGame}>Export</button>
              <input ref={importInputRef} type="file" accept="application/json" style={{ display: 'none' }} onChange={(e) => { if (e.target.files && e.target.files[0]) importGame(e.target.files[0]); e.target.value = null; }} />
              <button className="menu-button" style={{ marginTop: 6 }} onClick={() => importInputRef.current && importInputRef.current.click()}>Import</button>
              <button className="menu-button" style={{ marginTop: 6 }} onClick={takeBack} disabled={!(statesHistoryRef && statesHistoryRef.current && statesHistoryRef.current.length > 0)}>Take Back</button>
              </>
              )
            }
            </div>
            <div className="status">AI playing: {aiSide || 'none'}</div>
            <div className="status">Game Over: {gameOver ? `yes â€” ${gameWinner || 'unknown'}` : 'no'}</div>
            <div className="status">Last double-step: {lastMove ? `to [${lastMove.to.x},${lastMove.to.y},${lastMove.to.z}] id:${lastMove.id}` : 'none'}</div>
            <div className="status">Status: {statusMessage || 'none'}</div>
            {/* CHECK / CHECKMATE indicator */}
            {gameOver && statusMessage && statusMessage.toLowerCase().includes('checkmate') ? (
              <div style={{ color: 'red', fontWeight: 'bold', marginTop: '8px' }}>CHECKMATE â€” Winner: {gameWinner ? (gameWinner.charAt(0).toUpperCase() + gameWinner.slice(1)) : 'Unknown'}</div>
            ) : (statusMessage && statusMessage.toLowerCase().includes('check') ? (
              <div style={{ color: 'red', fontWeight: 'bold', marginTop: '8px' }}>CHECK</div>
            ) : null)}

            <div style={{ marginTop: '10px' }}>
              <div style={{ fontWeight: 'bold', marginBottom: '6px' }}>Moves</div>
              <div style={{ fontFamily: 'monospace', fontSize: '13px' }}>
                {moveHistory.length === 0 ? <div style={{ color: '#888' }}>no moves</div> : (
                  <table style={{ width: '100%', borderCollapse: 'collapse' }}>
                    <tbody>
                      {moveHistory.map((mv, idx) => (
                        <tr key={`mh-${idx}`}>
                          <td style={{ width: '40px', paddingRight: '6px' }}>{idx + 1}:</td>
                          <td style={{ width: '50%', paddingRight: '6px' }}>{mv.white || ''}</td>
                          <td style={{ width: '50%' }}>{mv.black || ''}</td>
                        </tr>
                      ))}
                    </tbody>
                  </table>
                )}
              </div>
            </div>
          </aside>
          <main className="main">
            <Canvas
              key={canvasKey}
              className="canvas"
              camera={{ position: camPos, fov: 32 }}
              onPointerMove={(e) => {
                try { pointerLastScreenRef.current = { x: e.clientX, y: e.clientY }; } catch {}
                // if pointer was pressed on a piece and user moved enough (screen-space), start dragging
                if (pointerDownRef.current && !isDragging && selectedPieceId != null && pointerStartScreenRef.current) {
                  const dx = e.clientX - pointerStartScreenRef.current.x;
                  const dy = e.clientY - pointerStartScreenRef.current.y;
                  const dist = Math.hypot(dx, dy);
                  // pixel threshold for consistent drag start across depths
                  if (dist > 6) {
                    setIsDragging(true);
                    // clear pending click-on-same-piece because we've started a drag
                    try { pointerDownPieceRef.current = null; } catch {}
                    try { if (controlsRef.current) controlsRef.current.enabled = false; } catch {}
                  }
                }
                // update drag point while pointer is down (so piece follows cursor immediately) or when dragging
                if (pointerDownRef.current || isDragging) {
                  // compute world point for ghost: prefer e.point (hit), otherwise raycast from camera to horizontal plane at dragHeight
                  let worldPoint = null;
                  // Prefer event point/ray; otherwise build ray from event.camera or controls camera
                  try {
                    if (e.point) {
                      worldPoint = new THREE.Vector3(e.point.x, e.point.y, e.point.z);
                      console.debug('used e.point');
                    } else if (pointerDepthRef && pointerDepthRef.current != null) {
                      // use stored clip-space depth to unproject mouse to world
                      try {
                        const canvas = document.querySelector('canvas');
                        if (canvas) {
                          const rect = canvas.getBoundingClientRect();
                          const nx = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                          const ny = -((e.clientY - rect.top) / rect.height) * 2 + 1;
                          const nz = pointerDepthRef.current;
                          const cam = e.camera || (controlsRef && controlsRef.current && controlsRef.current.object);
                            if (cam) {
                            const v = new THREE.Vector3(nx, ny, nz).unproject(cam);
                            worldPoint = v;
                            console.debug('used depth-unproject');
                          }
                        }
                      } catch (err) {}
                    } else {
                      const ray = e.ray;
                      let ro, rd;
                        if (ray) {
                        ro = ray.origin;
                        rd = ray.direction;
                        console.debug('used e.ray');
                      } else {
                        const cam = e.camera || (controlsRef.current && controlsRef.current.object);
                        if (cam && document.querySelector('canvas')) {
                          const canvas = document.querySelector('canvas');
                          const rect = canvas.getBoundingClientRect();
                          const x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                          const y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
                          const rc = new THREE.Raycaster();
                          rc.setFromCamera(new THREE.Vector2(x, y), cam);
                          ro = rc.ray.origin;
                          rd = rc.ray.direction;
                          console.debug('used camera raycaster');
                        }
                      }
                      if (ro && rd) {
                        const planeY = dragHeight;
                        if (Math.abs(rd.y) > 1e-6) {
                          const t = (planeY - ro.y) / rd.y;
                          console.debug(`t=${t.toFixed(3)}`);
                          if (t > 0.001 && t < 200) {
                            worldPoint = new THREE.Vector3().copy(rd).multiplyScalar(t).add(ro);
                          } else {
                            // fallback: compute intersection using unproject(near/far) to avoid negative/behind-camera t issues
                            try {
                              if (document.querySelector('canvas')) {
                                const canvas = document.querySelector('canvas');
                                const rect = canvas.getBoundingClientRect();
                                const nx = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                                const ny = -((e.clientY - rect.top) / rect.height) * 2 + 1;
                                const nearV = new THREE.Vector3(nx, ny, -1).unproject(e.camera || (controlsRef.current && controlsRef.current.object));
                                const farV = new THREE.Vector3(nx, ny, 1).unproject(e.camera || (controlsRef.current && controlsRef.current.object));
                                const denom = farV.y - nearV.y;
                                if (Math.abs(denom) > 1e-6) {
                                  const u = (planeY - nearV.y) / denom;
                                  console.debug(`fallback u=${u.toFixed(3)}`);
                                  worldPoint = new THREE.Vector3().copy(nearV).lerp(farV, u);
                                }
                              }
                            } catch (err) { }
                            }
                          }
                        }
                      }
                    } catch (err) {
                    console.debug('ray compute error');
                  }

                  if (worldPoint) {
                    setDragPointWorld([worldPoint.x, worldPoint.y, worldPoint.z]);
                    if (groupRef.current) {
                      const v = worldPoint.clone();
                      groupRef.current.worldToLocal(v);
                      // use the transformed local y directly and add small offset to avoid z-fighting
                      v.y = v.y + 0.02;
                      setDragPoint([v.x, v.y, v.z]);
                    } else {
                      setDragPoint([worldPoint.x / sceneScale, dragHeight + 0.02, worldPoint.z / sceneScale]);
                    }
                  }
                }
              }}
              onPointerUp={(e) => {
                // if we were dragging, send the last world point for drop processing
                if (isDragging && dragPointWorld) {
                  setPendingDrop(dragPointWorld);
                }
                // if pointer up and it was NOT a drag, and we started the press on a piece, treat as click toggle
                if (!isDragging && pointerDownPieceRef.current) {
                  try {
                    const pid = pointerDownPieceRef.current;
                    if (pointerDownWasSelectedRef.current) {
                      // toggle when user pressed the already-selected piece
                      if (selectedPieceId === pid) setSelectedPieceId(null);
                      else setSelectedPieceId(pid);
                    } else {
                      // user pressed a different piece: ensure it is selected
                      if (selectedPieceId !== pid) setSelectedPieceId(pid);
                    }
                  } catch (err) {}
                }
                // release drag anywhere
                pointerDownRef.current = false;
                try { pointerDownPieceRef.current = null; pointerDownWasSelectedRef.current = false; } catch {}
                pointerStartRef.current = null;
                try { pointerStartScreenRef.current = null; } catch {}
                try { if (pointerDepthRef) pointerDepthRef.current = null; } catch {}
                setIsDragging(false);
                setDragPointWorld(null);
                setPointerActive(false);
                // always re-enable controls on pointer up
                try { if (controlsRef.current) controlsRef.current.enabled = true; } catch {}
              }}
            >
              {/* Diagnostic: log Canvas mount/unmount via a proper component */}
              <CanvasLogger canvasKey={canvasKey} />
              <ambientLight intensity={0.6} />
              <R3FResize />
              <directionalLight position={[5, 12, 5]} intensity={0.9} />
              <group ref={groupRef} scale={sceneScale}>
                <QuadLevelBoard flipBoard={(currentTurn === 'black') && !aiSide} />
                <Pieces
                  piecesState={piecesState}
                  setPiecesState={setPiecesState}
                  selectedPieceId={selectedPieceId}
                  setSelectedPieceId={setSelectedPieceId}
                  isDragging={isDragging}
                  dragPoint={dragPoint}
                  setIsDragging={setIsDragging}
                  setDragPoint={setDragPoint}
                  dragPointWorld={dragPointWorld}
                  setDragPointWorld={setDragPointWorld}
                  setPointerActive={setPointerActive}
                  controlsRef={controlsRef}
                  pointerDownRef={pointerDownRef}
                  pointerStartRef={pointerStartRef}
                  pointerDepthRef={pointerDepthRef}
                  showCastlePrompt={showCastlePrompt}
                   kingGltf={kingGltf}
                   pawnGltf={pawnGltf}
                   knightGltf={knightGltf}
                   bishopGltf={bishopGltf}
                   rookGltf={rookGltf}
                   queenGltf={queenGltf}
                   clones={clones}
                  pointerDownPieceRef={pointerDownPieceRef}
                  pointerStartScreenRef={pointerStartScreenRef}
                  pointerLastScreenRef={pointerLastScreenRef}
                  pendingDrop={pendingDrop}
                  setPendingDrop={setPendingDrop}
                  groupRef={groupRef}
                  setDragHeight={setDragHeight}
                  sceneScale={sceneScale}
                  currentTurn={currentTurn}
                  setCurrentTurn={setCurrentTurn}
                  lastMove={lastMove}
                    setLastMove={setLastMove}
                    pointerDownWasSelectedRef={pointerDownWasSelectedRef}
                    setMoveHistory={setMoveHistory}
                    moveHistory={moveHistory}
                    gameOver={gameOver}
                    generateMoveNotation={generateMoveNotation}
                    moveLockRef={moveLockRef}
                    aiSide={aiSide}
                    pushStateSnapshot={pushStateSnapshot}
                />
                <Ghost dragPoint={dragPoint} dragPointWorld={dragPointWorld} selectedPieceId={selectedPieceId} piecesState={piecesState} isDragging={isDragging} pointerDownRef={pointerDownRef} kingGltf={kingGltf} pawnGltf={pawnGltf} knightGltf={knightGltf} bishopGltf={bishopGltf} rookGltf={rookGltf} queenGltf={queenGltf} clones={clones} currentTurn={currentTurn} />
                
              </group>
                
              <OrbitControls
                ref={controlsRef}
                makeDefault
                enablePan={false}
                enableDamping={true}
                dampingFactor={0.08}
                rotateSpeed={0.45}
                zoomSpeed={0.6}
                target={camTarget}
                onEnd={() => {
                  // persist camera and target when user finishes interacting
                  const c = controlsRef.current;
                  if (!c) return;
                  const cam = c.object;
                  if (cam) {
                    const pos = [cam.position.x, cam.position.y, cam.position.z];
                    setCamPos(pos);
                    try { localStorage.setItem('camPos', JSON.stringify(pos)); } catch {}
                  }
                  if (c.target) {
                    const tgt = [c.target.x, c.target.y, c.target.z];
                    setCamTarget(tgt);
                    try { localStorage.setItem('camTarget', JSON.stringify(tgt)); } catch {}
                  }
                }}
              />
            </Canvas>
          </main>
        </div>
        {castlePrompt ? (
          <div style={{ position: 'fixed', left: 0, top: 0, right: 0, bottom: 0, display: 'flex', alignItems: 'center', justifyContent: 'center', pointerEvents: 'auto' }}>
            <div style={{ background: 'rgba(0,0,0,0.6)', position: 'absolute', left: 0, top: 0, right: 0, bottom: 0 }} />
            <div style={{ zIndex: 9999, background: '#fff', padding: 20, borderRadius: 8, minWidth: 260, boxShadow: '0 10px 30px rgba(0,0,0,0.4)', textAlign: 'center' }}>
              <div style={{ fontWeight: 'bold', marginBottom: 8 }}>{castlePrompt.title || 'Confirm'}</div>
              <div style={{ marginBottom: 12, color: '#333' }}>Do you want to perform the castle-type move?</div>
              <div style={{ display: 'flex', gap: 10, justifyContent: 'center' }}>
                <button onClick={() => { try { castlePrompt.onYes && castlePrompt.onYes(); } catch (e) {} setCastlePrompt(null); }} style={{ padding: '6px 12px' }}>Yes</button>
                <button onClick={() => { try { castlePrompt.onNo && castlePrompt.onNo(); } catch (e) {} setCastlePrompt(null); }} style={{ padding: '6px 12px' }}>No</button>
              </div>
            </div>
          </div>
        ) : null}

        </>
      );
    }
//                setCamTarget(tgt);
  //              try { localStorage.setItem('camTarget', JSON.stringify(tgt)); } catch {}
    //          }
      //      }}
        //  />
        //</Canvas>
      //</main>
    //</div>
  //);
//}
