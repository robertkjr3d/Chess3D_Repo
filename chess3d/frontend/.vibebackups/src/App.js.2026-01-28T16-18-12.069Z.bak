import { useState, useRef, useEffect, useMemo, useCallback } from "react";
import * as THREE from 'three';
import { Canvas, useThree, useFrame } from "@react-three/fiber";
import { OrbitControls, useGLTF } from "@react-three/drei";
import "./App.css";

const GLOBAL_PIECE_SCALE = {
  pawn: 0.013,
  knight: 0.013,
  bishop: 0.013,
  rook: 0.013,
  queen: 0.013,
  king: 0.013,
};
const GHOST_SCALE_FACTOR = 1.0;
// Per-level multiplier applied to the dragged ghost.
// Note: logical level `z` is ordered with z=0 at the TOP board and z=3 at the BOTTOM board.
// Index mapping: DRAG_LEVEL_SCALE[0] -> top board (z0), ... DRAG_LEVEL_SCALE[3] -> bottom board (z3).
// Tweak these values to make ghosts smaller/larger per-board level.
//const DRAG_LEVEL_SCALE = [1.0, 0.8, 0.7, 0.6];
const DRAG_LEVEL_SCALE = [0.6, 0.7, 0.8, 1.0];

// Y positions for each logical level `z` (index 0 = TOP board, index 3 = BOTTOM board)
const LEVEL_Y = [8.75, 6.6, 3.725, 0];

function cloneAndColor(gltf, color) {
  const obj = gltf.scene.clone(true);
  // normalize any embedded scale so external scale props control final size
  try { obj.scale.set(1,1,1); } catch (err) {}
  // compute bounding box and normalize to unit height so different model units match
  try {
    const box = new THREE.Box3().setFromObject(obj);
    const size = new THREE.Vector3();
    box.getSize(size);
    const h = size.y || 0;
    if (h > 1e-6) {
      const f = 1.0 / h;
      try { obj.scale.set(f, f, f); } catch (err) {}
      obj.userData._normalizedHeight = h;
    }
  } catch (err) {}

  obj.traverse((n) => {
    if (n.isMesh) {
      if (n.material) {
        n.material = n.material.clone();
        try { n.material.color.set(color); } catch (e) {}
        n.castShadow = true;
        n.receiveShadow = true;
      }
    }
  });
  return obj;
}

    function Square({ position, color }) {
      return (
        <mesh position={position}>
          <boxGeometry args={[1, 0.15, 1]} />
          <meshStandardMaterial color={color} />
        </mesh>
      );
    }

    function BoardLevel({ y, flip = false }) {
      const squares = [];
      for (let x = 0; x < 8; x++) {
        for (let row = 0; row < 4; row++) {
          // within-board rows use logical y; flip so logical y=0 maps to visual top within board
          const yIndex = 3 - row;
          const isWhite = ((x + yIndex + (flip ? 1 : 0)) % 2) !== 0;
          squares.push(
            <Square
              key={`${y}-${x}-${row}`}
              // world coordinates: X, world Y (level), world Z (in-board row)
              position={[x - 3.5, y, yIndex - 3.5]}
              color={isWhite ? "#f0d9b5" : "#b58863"}
            />
          );
        }
      }
      return <group>{squares}</group>;
    }

    function QuadLevelBoard() {
      // render from bottom -> top for correct visual stacking
      const bottomToTop = LEVEL_Y.slice().reverse();
      return (
        <group>
          {bottomToTop.map((y, i) => <BoardLevel key={`lvl-${i}`} y={y} flip={i % 2 === 0} />)}
        </group>
      );
    }

    function Pieces({ piecesState, setPiecesState, selectedPieceId, setSelectedPieceId, isDragging, dragPoint, setIsDragging, setDragPoint, dragPointWorld, setDragPointWorld, setPointerActive, controlsRef, pointerDownRef, pointerStartRef, pointerStartScreenRef, pointerDepthRef, kingGltf, pawnGltf, knightGltf, bishopGltf, rookGltf, queenGltf, clones, pendingDrop, setPendingDrop, groupRef, setDragHeight, sceneScale }) {
      const levels = LEVEL_Y;
      const pieces = [];

      // Per-piece scale constants (tweak these if models look too big/small)
      const scaleMap = GLOBAL_PIECE_SCALE;

      // piecesState is an array of piece objects with {id,x,y,z,t,color}
      const allPieces = piecesState;

      // occupancy set keyed by logical coords (unused currently)

      // helper to convert logical coords to world positions
      function worldPosFromLogical(lx, ly, lz) {
        const wx = lx - 3.5;
        const wy = levels[lz] + 0.11;
        const wz = (3 - ly) - 3.5;
        return [wx, wy, wz];
      }

      // compute legal moves for a selected white piece (pawns + knights)
      const legalMoves = useMemo(() => {
        const occupiedMap = new Map(allPieces.map((p) => [`${p.x},${p.y},${p.z}`, p.color]));
        const moves = [];
        if (selectedPieceId == null) return moves;
        const sel = allPieces.find((pp) => pp.id === selectedPieceId);
        if (!sel || sel.color !== 'white') return moves;
        const { x: sx, y: sy, z: sz, t: st } = sel;
        if (st === 'p') {
          const oneX = sx - 1;
          const twoX = sx - 2;
          if (oneX >= 0 && !occupiedMap.has(`${oneX},${sy},${sz}`)) {
            moves.push({ x: oneX, y: sy, z: sz });
            if (sx === 6 && twoX >= 0 && !occupiedMap.has(`${twoX},${sy},${sz}`)) {
              moves.push({ x: twoX, y: sy, z: sz });
            }
          }
        }
        if (st === 'N') {
          // Knight moves allowed only in X-Y (dz=0) or X-Z (dy=0) planes
          const perms = [[2, 1, 0], [1, 2, 0], [2, 0, 1], [1, 0, 2]];
          const moveSet = new Set();
          perms.forEach(([ax, ay, az]) => {
            const xs = ax === 0 ? [0] : [-ax, ax];
            const ys = ay === 0 ? [0] : [-ay, ay];
            const zs = az === 0 ? [0] : [-az, az];
            xs.forEach((dx) => ys.forEach((dy) => zs.forEach((dz) => {
              // enforce plane constraint: either dz===0 (XY move) or dy===0 (XZ move)
              if (!(dz === 0 || dy === 0)) return;
              const nx = sx + dx;
              const ny = sy + dy;
              const nz = sz + dz;
              if (nx < 0 || nx > 7 || ny < 0 || ny > 3 || nz < 0 || nz > 3) return;
              const key = `${nx},${ny},${nz}`;
              if (occupiedMap.get(key) === 'white') return;
              moveSet.add(key);
            })));
          });
          moveSet.forEach((k) => {
            const [x, y, z] = k.split(',').map(Number);
            moves.push({ x, y, z });
          });
        }
        // Rook: straight lines along x, y, or z (can move between levels vertically)
        if (st === 'R') {
          const dirs = [[1,0,0],[-1,0,0],[0,1,0],[0,-1,0],[0,0,1],[0,0,-1]];
          dirs.forEach(([dx,dy,dz]) => {
            let step = 1;
            while (true) {
              const nx = sx + dx*step;
              const ny = sy + dy*step;
              const nz = sz + dz*step;
              if (nx < 0 || nx > 7 || ny < 0 || ny > 3 || nz < 0 || nz > 3) break;
              const key = `${nx},${ny},${nz}`;
              const occ = occupiedMap.get(key);
              if (occ === 'white') break;
              moves.push({ x: nx, y: ny, z: nz });
              if (occ && occ !== 'white') break;
              step++;
            }
          });
        }

        // Bishop: diagonal moves in X-Y or X-Z planes
        if (st === 'B') {
          const dirs = [[1,1,0],[1,-1,0],[-1,1,0],[-1,-1,0],[1,0,1],[1,0,-1],[-1,0,1],[-1,0,-1]];
          dirs.forEach(([dx,dy,dz]) => {
            let step = 1;
            while (true) {
              const nx = sx + dx*step;
              const ny = sy + dy*step;
              const nz = sz + dz*step;
              if (nx < 0 || nx > 7 || ny < 0 || ny > 3 || nz < 0 || nz > 3) break;
              const key = `${nx},${ny},${nz}`;
              const occ = occupiedMap.get(key);
              if (occ === 'white') break;
              moves.push({ x: nx, y: ny, z: nz });
              if (occ && occ !== 'white') break;
              step++;
            }
          });
        }

        // Queen: combination of rook + bishop
        if (st === 'Q') {
          const dirs = [[1,0,0],[-1,0,0],[0,1,0],[0,-1,0],[0,0,1],[0,0,-1],[1,1,0],[1,-1,0],[-1,1,0],[-1,-1,0],[1,0,1],[1,0,-1],[-1,0,1],[-1,0,-1]];
          dirs.forEach(([dx,dy,dz]) => {
            let step = 1;
            while (true) {
              const nx = sx + dx*step;
              const ny = sy + dy*step;
              const nz = sz + dz*step;
              if (nx < 0 || nx > 7 || ny < 0 || ny > 3 || nz < 0 || nz > 3) break;
              const key = `${nx},${ny},${nz}`;
              const occ = occupiedMap.get(key);
              if (occ === 'white') break;
              moves.push({ x: nx, y: ny, z: nz });
              if (occ && occ !== 'white') break;
              step++;
            }
          });
        }

        // King: one-step in queen directions
        if (st === 'K') {
          const dirs = [[1,0,0],[-1,0,0],[0,1,0],[0,-1,0],[0,0,1],[0,0,-1],[1,1,0],[1,-1,0],[-1,1,0],[-1,-1,0],[1,0,1],[1,0,-1],[-1,0,1],[-1,0,-1]];
          dirs.forEach(([dx,dy,dz]) => {
            const nx = sx + dx;
            const ny = sy + dy;
            const nz = sz + dz;
            if (nx < 0 || nx > 7 || ny < 0 || ny > 3 || nz < 0 || nz > 3) return;
            const key = `${nx},${ny},${nz}`;
            if (occupiedMap.get(key) === 'white') return;
            moves.push({ x: nx, y: ny, z: nz });
          });
        }
        return moves;
      }, [allPieces, selectedPieceId]);

      // render all pieces
      allPieces.forEach((p, idx) => {
        const world = worldPosFromLogical(p.x, p.y, p.z);
        const modelMap = {
          R: rookGltf,
          N: knightGltf,
          B: bishopGltf,
          K: kingGltf,
          Q: queenGltf,
          p: pawnGltf,
        };
        const gltf = modelMap[p.t] || pawnGltf;
        const pieceNameMap = { N: 'knight', B: 'bishop', K: 'king', Q: 'queen' };
        const s = scaleMap[pieceNameMap[p.t] || 'pawn'];

        // clickable group for white pawns and knights
        const isWhite = p.color === 'white';
        const isSelected = selectedPieceId === p.id;
        // When selected and actively dragging, render the piece at the computed local `dragPoint`
        const pos = isSelected && isDragging ? dragPoint : world;
        const visible = !(isSelected && isDragging);
        pieces.push(
          <group
            key={`${p.id}-${p.t}-${idx}`}
            position={pos}
            visible={visible}
                onPointerDown={(e) => {
              e.stopPropagation();
              try { if (pointerStartScreenRef) pointerStartScreenRef.current = { x: e.clientX, y: e.clientY }; } catch {}
              // toggle selection when clicking same piece
                if (isWhite) {
                if (selectedPieceId === p.id) {
                  // toggle off selection, but keep controls disabled until pointer up
                  setSelectedPieceId(null);
                  pointerDownRef.current = false;
                  pointerStartRef.current = null;
                  try { if (setPointerActive) setPointerActive(true); } catch {}
                  return;
                }
                setSelectedPieceId(p.id);
                // record pointer-down start and initial drag height; don't start dragging yet
                pointerDownRef.current = true;
                pointerStartRef.current = e.point || null;
                // store clip-space depth (NDC z) for later unprojection if camera available
                try {
                  const cam = e.camera || (controlsRef && controlsRef.current && controlsRef.current.object);
                  if (cam && pointerDepthRef) {
                    const vv = new THREE.Vector3(world[0], world[1], world[2]);
                    vv.project(cam);
                    pointerDepthRef.current = vv.z;
                  }
                } catch (err) {}
                // convert initial world pos into group's local coords so ghost appears at same place
                if (groupRef.current) {
                  try {
                    const lv = new THREE.Vector3(world[0], world[1], world[2]);
                    groupRef.current.worldToLocal(lv);
                    setDragPoint([lv.x, lv.y, lv.z]);
                  } catch (err) {
                    setDragPoint(world);
                  }
                } else {
                  setDragPoint([world[0] / sceneScale, world[1], world[2] / sceneScale]);
                }
                setDragHeight(world[1]);
                    try { if (setDragPointWorld) setDragPointWorld([e.point.x, e.point.y, e.point.z]); } catch {}
                    try { if (setPointerActive) setPointerActive(true); } catch {}
                // immediately disable OrbitControls so the board doesn't move while attempting drag
                try { if (controlsRef.current) controlsRef.current.enabled = false; } catch {}
              } else {
                setSelectedPieceId(null);
              }
            }}
          >
            <primitive
              object={(clones && clones[`${p.t}-${isWhite ? 'white' : '#615c5c'}`]) ? clones[`${p.t}-${isWhite ? 'white' : '#615c5c'}`].clone(true) : cloneAndColor(gltf, isWhite ? '#ffffff' : '#615c5c')}
              scale={s}
              rotation={isWhite ? [0, Math.PI, 0] : [0, 0, 0]}
            />
          </group>
        );
      });

      // render move indicators (red dots)
      const moveTo = useCallback((target) => {
        if (selectedPieceId == null) return;
        setPiecesState((prev) => {
          const withoutCaptured = prev.filter(
            (pp) => !(pp.x === target.x && pp.y === target.y && pp.z === target.z && pp.color === 'black')
          );
          return withoutCaptured.map((pp) =>
            pp.id === selectedPieceId ? { ...pp, x: target.x, y: target.y, z: target.z } : pp
          );
        });
        setSelectedPieceId(null);
      }, [selectedPieceId, setPiecesState, setSelectedPieceId]);

      // when App reports a pendingDrop, decide whether it's a legal landing square
      useEffect(() => {
        if (!pendingDrop) return;
        if (selectedPieceId == null) {
          setPendingDrop(null);
          return;
        }
        try {
          // convert world point to local coords
          const v = new THREE.Vector3(pendingDrop[0], pendingDrop[1], pendingDrop[2]);
          if (groupRef && groupRef.current) groupRef.current.worldToLocal(v);
          // determine nearest logical coords
          const lx = Math.round(v.x + 3.5);
          const ly = Math.round(3 - (v.z + 3.5));
          // pick level by closest Y
          const levels = LEVEL_Y;
          let lz = 0;
          let bestDist = Infinity;
          for (let i = 0; i < levels.length; i++) {
            const d = Math.abs(v.y - (levels[i] + 0.11));
            if (d < bestDist) { bestDist = d; lz = i; }
          }
          const key = `${lx},${ly},${lz}`;
          const legalSet = new Set(legalMoves.map(m => `${m.x},${m.y},${m.z}`));
          if (legalSet.has(key)) {
            moveTo({ x: lx, y: ly, z: lz });
          } else {
            // cancel drag: clear selection and leave piecesState unchanged
            setSelectedPieceId(null);
          }
        } catch (e) {}
        setPendingDrop(null);
        // ensure dragging state cleared
        try { if (controlsRef && controlsRef.current) controlsRef.current.enabled = true; } catch {}
        try { pointerDownRef.current = false; } catch {}
        setIsDragging(false);
        setDragPointWorld(null);
        setPointerActive(false);
      }, [pendingDrop, controlsRef, groupRef, /*legalMoves*/ legalMoves, moveTo, pointerDownRef, selectedPieceId, setDragPointWorld, setIsDragging, setPendingDrop, setPointerActive, setSelectedPieceId]);

      const indicators = legalMoves.map((m, i) => {
        const wp = worldPosFromLogical(m.x, m.y, m.z);
        return (
          <mesh key={`move-ind-${i}`} position={wp} onPointerUp={(e) => { e.stopPropagation(); moveTo(m); try { if (controlsRef.current) controlsRef.current.enabled = true; } catch{} }}>
            <sphereGeometry args={[0.14, 16, 16]} />
            <meshStandardMaterial color="#ff0000" />
          </mesh>
        );
      });

      return <group>{pieces.concat(indicators)}</group>;
    }

    function Ghost({ dragPoint, dragPointWorld, selectedPieceId, piecesState, isDragging, pointerDownRef, kingGltf, pawnGltf, knightGltf, bishopGltf, rookGltf, queenGltf, clones }) {
      const sel = piecesState.find((p) => p.id === selectedPieceId);
      const modelMap = {
        R: rookGltf,
        N: knightGltf,
        B: bishopGltf,
        K: kingGltf,
        Q: queenGltf,
        p: pawnGltf,
      };
      const gltf = sel ? (modelMap[sel.t] || pawnGltf) : null;
      const color = sel ? (sel.color === 'white' ? '#ffffff' : '#615c5c') : '#ffffff';

      // create a clone and make it render on top (hook always called)
      const cloned = useMemo(() => {
        if (!gltf || !sel) return null;
        try {
          const cacheKey = `${sel.t}-${sel.color === 'white' ? 'white' : '#615c5c'}`;
          const c = (clones && clones[cacheKey]) ? clones[cacheKey].clone(true) : cloneAndColor(gltf, color);
          c.traverse((n) => {
            if (n.isMesh && n.material) {
              try { n.material = n.material.clone(); } catch (err) {}
              n.material.transparent = true;
              n.material.opacity = 0.95;
              n.material.depthTest = false;
              n.material.depthWrite = false;
              n.renderOrder = 999;
            }
          });
          return c;
        } catch (err) { return null; }
      }, [gltf, color, selectedPieceId, sel, clones]);

      // show ghost only while actively dragging; don't render on simple pointer-down
      if (!dragPoint || !sel || !isDragging) return null;

      if (!cloned) return null;

      const s = GLOBAL_PIECE_SCALE[sel.t === 'N' ? 'knight' : (sel.t === 'p' ? 'pawn' : (sel.t === 'B' ? 'bishop' : (sel.t === 'R' ? 'rook' : (sel.t === 'Q' ? 'queen' : 'king'))))] || 0.013;

      // Apply per-level multiplier so lower boards can have smaller ghosts.
      const levelIndex = (typeof sel.z === 'number') ? sel.z : 3;
      const levelFactor = (DRAG_LEVEL_SCALE && DRAG_LEVEL_SCALE[levelIndex] != null) ? DRAG_LEVEL_SCALE[levelIndex] : 1.0;
      const finalScale = s * levelFactor * GHOST_SCALE_FACTOR;

      // Ghost is rendered inside the same scaled group as pieces; use the adjusted scale so it matches.
      return (
        <group raycast={() => null} renderOrder={999}>
          <primitive object={cloned} position={dragPoint} scale={[finalScale, finalScale, finalScale]} />
        </group>
      );
    }

    export default function App() {
      const [aiSide, setAiSide] = useState(null);
      const [selectedPieceId, setSelectedPieceId] = useState(null);
      const [isDragging, setIsDragging] = useState(false);
      const [dragPoint, setDragPoint] = useState([0, 0, 0]);
      const [dragHeight, setDragHeight] = useState(0);
      const [dragPointWorld, setDragPointWorld] = useState(null);
      
      const [pendingDrop, setPendingDrop] = useState(null);
      const [pointerActive, setPointerActive] = useState(false);
      const pointerDownRef = useRef(false);
      const pointerStartRef = useRef(null);
      const pointerDepthRef = useRef(null);
      const pointerStartScreenRef = useRef(null);
      const groupRef = useRef();
      const sceneScale = 0.470;
      // load models once at App level and pass to children
      const kingGltf = useGLTF('/models/king2.glb');
      const pawnGltf = useGLTF('/models/pawn2.glb');
      const knightGltf = useGLTF('/models/knight_-_staunton_full_size_chess_set.glb');
      const bishopGltf = useGLTF('/models/bishop_-_staunton_full_size_chess_set.glb');
      const rookGltf = useGLTF('/models/rook_-_staunton_full_size_chess_set.glb');
      const queenGltf = useGLTF('/models/queen_-_staunton_full_size_chess_set.glb');

      // build a cache of normalized clones per piece type + color so ghost and piece share same object
      const clones = useMemo(() => {
        const map = {};
        const modelMap = { R: rookGltf, N: knightGltf, B: bishopGltf, K: kingGltf, Q: queenGltf, p: pawnGltf };
        ['white','#615c5c'].forEach((colorHex) => {
          Object.keys(modelMap).forEach((t) => {
            try {
              const c = cloneAndColor(modelMap[t], colorHex);
              map[`${t}-${colorHex}`] = c;
            } catch (err) {}
          });
        });
        return map;
      }, [kingGltf, pawnGltf, knightGltf, bishopGltf, rookGltf, queenGltf]);
      

      // build initial pieces list (logical coords)
      function getInitialPieces() {
        const levels = [0, 1, 2, 3]; // logical levels
        const res = [];
        let id = 1;
        levels.forEach((lz) => {
          for (let row = 0; row < 4; row++) {
            res.push({ id: id++, x: 1, y: row, z: lz, t: 'p', color: 'black' });
            res.push({ id: id++, x: 6, y: row, z: lz, t: 'p', color: 'white' });
          }
        });

        const placements = [
          { x: 0, y: 0, z: 0, t: 'R' },
          { x: 0, y: 1, z: 0, t: 'N' },
          { x: 0, y: 2, z: 0, t: 'B' },
          { x: 0, y: 3, z: 0, t: 'R' },
          { x: 0, y: 0, z: 1, t: 'B' },
          { x: 0, y: 1, z: 1, t: 'K' },
          { x: 0, y: 2, z: 1, t: 'Q' },
          { x: 0, y: 3, z: 1, t: 'N' },
          { x: 0, y: 0, z: 2, t: 'N' },
          { x: 0, y: 1, z: 2, t: 'Q' },
          { x: 0, y: 2, z: 2, t: 'K' },
          { x: 0, y: 3, z: 2, t: 'B' },
          { x: 0, y: 0, z: 3, t: 'R' },
          { x: 0, y: 1, z: 3, t: 'B' },
          { x: 0, y: 2, z: 3, t: 'N' },
          { x: 0, y: 3, z: 3, t: 'R' },
        ];
        placements.forEach((p) => {
          res.push({ id: id++, x: p.x, y: p.y, z: p.z, t: p.t, color: 'black' });
          res.push({ id: id++, x: 7 - p.x, y: p.y, z: p.z, t: p.t, color: 'white' });
        });
        return res;
      }

      const [piecesState, setPiecesState] = useState(() => getInitialPieces());

      // camera / controls persistence
      const controlsRef = useRef();
      // prefer explicit saved defaults if present; otherwise fall back to last-used camPos
      const [camPos, setCamPos] = useState(() => {
        try {
          return JSON.parse(localStorage.getItem('camDefaultPos')) || JSON.parse(localStorage.getItem('camPos')) || [6, 5, -8];
        } catch { return [6,5,-8]; }
      });
      const [camTarget, setCamTarget] = useState(() => {
        try {
          return JSON.parse(localStorage.getItem('camDefaultTarget')) || JSON.parse(localStorage.getItem('camTarget')) || [0, 1.7, 0];
        } catch { return [0,1.7,0]; }
      });

      useEffect(() => {
        // apply saved target to controls when they mount
        if (controlsRef.current) {
          const c = controlsRef.current;
          if (c.target && Array.isArray(camTarget)) {
            c.target.set(camTarget[0], camTarget[1], camTarget[2]);
            c.update();
          }
          // ensure camera position if accessible
          if (c.object && Array.isArray(camPos)) {
            c.object.position.set(camPos[0], camPos[1], camPos[2]);
          }
        }
      }, [controlsRef, camPos, camTarget]);

      // keep OrbitControls enabled state in sync with pointer interaction/dragging
      useEffect(() => {
        try {
          if (controlsRef.current) {
            controlsRef.current.enabled = !pointerActive && !isDragging;
          }
        } catch (e) {}
      }, [pointerActive, isDragging, controlsRef]);



      return (
        <>
        <div className="layout">
          <aside className="sidebar">
            <h2 className="title">Quadlevel 3D Chess</h2>
            <div className="menu">
              <button className="menu-button" onClick={() => setAiSide('white')}>
                Play AI White
              </button>
              <button className="menu-button" onClick={() => setAiSide('black')}>
                Play AI Black
              </button>
            </div>
            {aiSide && <div className="status">AI playing: {aiSide}</div>}
          </aside>
          <main className="main">
            <Canvas
              className="canvas"
              camera={{ position: camPos, fov: 32 }}
              onPointerMove={(e) => {
                // if pointer was pressed on a piece and user moved enough (screen-space), start dragging
                if (pointerDownRef.current && !isDragging && selectedPieceId != null && pointerStartScreenRef.current) {
                  const dx = e.clientX - pointerStartScreenRef.current.x;
                  const dy = e.clientY - pointerStartScreenRef.current.y;
                  const dist = Math.hypot(dx, dy);
                  // pixel threshold for consistent drag start across depths
                  if (dist > 6) {
                    setIsDragging(true);
                    try { if (controlsRef.current) controlsRef.current.enabled = false; } catch {}
                  }
                }
                // update drag point while pointer is down (so piece follows cursor immediately) or when dragging
                if (pointerDownRef.current || isDragging) {
                  // compute world point for ghost: prefer e.point (hit), otherwise raycast from camera to horizontal plane at dragHeight
                  let worldPoint = null;
                  // Prefer event point/ray; otherwise build ray from event.camera or controls camera
                  try {
                    if (e.point) {
                      worldPoint = new THREE.Vector3(e.point.x, e.point.y, e.point.z);
                      console.debug('used e.point');
                    } else if (pointerDepthRef && pointerDepthRef.current != null) {
                      // use stored clip-space depth to unproject mouse to world
                      try {
                        const canvas = document.querySelector('canvas');
                        if (canvas) {
                          const rect = canvas.getBoundingClientRect();
                          const nx = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                          const ny = -((e.clientY - rect.top) / rect.height) * 2 + 1;
                          const nz = pointerDepthRef.current;
                          const cam = e.camera || (controlsRef && controlsRef.current && controlsRef.current.object);
                            if (cam) {
                            const v = new THREE.Vector3(nx, ny, nz).unproject(cam);
                            worldPoint = v;
                            console.debug('used depth-unproject');
                          }
                        }
                      } catch (err) {}
                    } else {
                      const ray = e.ray;
                      let ro, rd;
                        if (ray) {
                        ro = ray.origin;
                        rd = ray.direction;
                        console.debug('used e.ray');
                      } else {
                        const cam = e.camera || (controlsRef.current && controlsRef.current.object);
                        if (cam && document.querySelector('canvas')) {
                          const canvas = document.querySelector('canvas');
                          const rect = canvas.getBoundingClientRect();
                          const x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                          const y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
                          const rc = new THREE.Raycaster();
                          rc.setFromCamera(new THREE.Vector2(x, y), cam);
                          ro = rc.ray.origin;
                          rd = rc.ray.direction;
                          console.debug('used camera raycaster');
                        }
                      }
                      if (ro && rd) {
                        const planeY = dragHeight;
                        if (Math.abs(rd.y) > 1e-6) {
                          const t = (planeY - ro.y) / rd.y;
                          console.debug(`t=${t.toFixed(3)}`);
                          if (t > 0.001 && t < 200) {
                            worldPoint = new THREE.Vector3().copy(rd).multiplyScalar(t).add(ro);
                          } else {
                            // fallback: compute intersection using unproject(near/far) to avoid negative/behind-camera t issues
                            try {
                              if (document.querySelector('canvas')) {
                                const canvas = document.querySelector('canvas');
                                const rect = canvas.getBoundingClientRect();
                                const nx = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                                const ny = -((e.clientY - rect.top) / rect.height) * 2 + 1;
                                const nearV = new THREE.Vector3(nx, ny, -1).unproject(e.camera || (controlsRef.current && controlsRef.current.object));
                                const farV = new THREE.Vector3(nx, ny, 1).unproject(e.camera || (controlsRef.current && controlsRef.current.object));
                                const denom = farV.y - nearV.y;
                                if (Math.abs(denom) > 1e-6) {
                                  const u = (planeY - nearV.y) / denom;
                                  console.debug(`fallback u=${u.toFixed(3)}`);
                                  worldPoint = new THREE.Vector3().copy(nearV).lerp(farV, u);
                                }
                              }
                            } catch (err) { }
                            }
                          }
                        }
                      }
                    } catch (err) {
                    console.debug('ray compute error');
                  }

                  if (worldPoint) {
                    setDragPointWorld([worldPoint.x, worldPoint.y, worldPoint.z]);
                    if (groupRef.current) {
                      const v = worldPoint.clone();
                      groupRef.current.worldToLocal(v);
                      // use the transformed local y directly and add small offset to avoid z-fighting
                      v.y = v.y + 0.02;
                      setDragPoint([v.x, v.y, v.z]);
                    } else {
                      setDragPoint([worldPoint.x / sceneScale, dragHeight + 0.02, worldPoint.z / sceneScale]);
                    }
                  }
                }
              }}
              onPointerUp={(e) => {
                // if we were dragging, send the last world point for drop processing
                if (isDragging && dragPointWorld) {
                  setPendingDrop(dragPointWorld);
                }
                // release drag anywhere
                pointerDownRef.current = false;
                pointerStartRef.current = null;
                try { pointerStartScreenRef.current = null; } catch {}
                try { if (pointerDepthRef) pointerDepthRef.current = null; } catch {}
                setIsDragging(false);
                setDragPointWorld(null);
                setPointerActive(false);
                // always re-enable controls on pointer up
                try { if (controlsRef.current) controlsRef.current.enabled = true; } catch {}
              }}
            >
              <ambientLight intensity={0.6} />
              <directionalLight position={[5, 12, 5]} intensity={0.9} />
              <group ref={groupRef} scale={sceneScale}>
                <QuadLevelBoard />
                <Pieces
                  piecesState={piecesState}
                  setPiecesState={setPiecesState}
                  selectedPieceId={selectedPieceId}
                  setSelectedPieceId={setSelectedPieceId}
                  isDragging={isDragging}
                  dragPoint={dragPoint}
                  setIsDragging={setIsDragging}
                  setDragPoint={setDragPoint}
                  dragPointWorld={dragPointWorld}
                  setDragPointWorld={setDragPointWorld}
                  setPointerActive={setPointerActive}
                  controlsRef={controlsRef}
                  pointerDownRef={pointerDownRef}
                  pointerStartRef={pointerStartRef}
                  pointerDepthRef={pointerDepthRef}
                   kingGltf={kingGltf}
                   pawnGltf={pawnGltf}
                   knightGltf={knightGltf}
                   bishopGltf={bishopGltf}
                   rookGltf={rookGltf}
                   queenGltf={queenGltf}
                   clones={clones}
                  pointerStartScreenRef={pointerStartScreenRef}
                  pendingDrop={pendingDrop}
                  setPendingDrop={setPendingDrop}
                  groupRef={groupRef}
                  setDragHeight={setDragHeight}
                  sceneScale={sceneScale}
                />
                <Ghost dragPoint={dragPoint} dragPointWorld={dragPointWorld} selectedPieceId={selectedPieceId} piecesState={piecesState} isDragging={isDragging} pointerDownRef={pointerDownRef} kingGltf={kingGltf} pawnGltf={pawnGltf} knightGltf={knightGltf} bishopGltf={bishopGltf} rookGltf={rookGltf} queenGltf={queenGltf} clones={clones} />
                
              </group>
                
              <OrbitControls
                ref={controlsRef}
                makeDefault
                enablePan={false}
                enableDamping={true}
                dampingFactor={0.08}
                rotateSpeed={0.45}
                zoomSpeed={0.6}
                target={camTarget}
                onEnd={() => {
                  // persist camera and target when user finishes interacting
                  const c = controlsRef.current;
                  if (!c) return;
                  const cam = c.object;
                  if (cam) {
                    const pos = [cam.position.x, cam.position.y, cam.position.z];
                    setCamPos(pos);
                    try { localStorage.setItem('camPos', JSON.stringify(pos)); } catch {}
                  }
                  if (c.target) {
                    const tgt = [c.target.x, c.target.y, c.target.z];
                    setCamTarget(tgt);
                    try { localStorage.setItem('camTarget', JSON.stringify(tgt)); } catch {}
                  }
                }}
              />
            </Canvas>
          </main>
        </div>
        
        </>
      );
    }
//                setCamTarget(tgt);
  //              try { localStorage.setItem('camTarget', JSON.stringify(tgt)); } catch {}
    //          }
      //      }}
        //  />
        //</Canvas>
      //</main>
    //</div>
  //);
//}
